---
title: "IOS Developer Olma Yolunda"
date: 1999-21-03
summary: "Frontend'den IOS developer olma yolundaki adımlarımı paylaşacağım."
---

<CustomImage src="/images/post/mobile/ios-developer-olma-kariyerim/001.png" width={1920} height={1080} fluid />

> Bu yazıdaki gün kavramı, IOS ile uğraştığım günleri ifade ediyor. Ardışık olarak 
> düşünmeyin. İki gün arasında haftalar olabilir.

## GÜN 1

IOS geliştirmede kullanılan Swift diliyle başlıyorum. Klasik değişken tipleri,
type, enum ile başlangıcı yaptım.

### Notlarım:

- Değişken oluşturmak için `var`, değeri asla değişmeyecek değişkenler
için `let` kullanırız.

```swift
let cityName = "Bursa"
let cityPlateCode = 16
let cityAreaInKm2 = 10.82
var cityPopulation = 2_161_990
let isCapital = false
```

> Integerlar alt cizgi ile basamakları daha okunabilir halde yazılabilir.

- Swift otomatik olarak değişken tiplerini tahmin eder (**inference**) ancak manuel
olarak da verebiliriz. Ondalıklı sayıları varsayılan olarak **Double** tipinde tutar.

```swift
let cityName: String = "Bursa"
let cityPlateCode: Int = 16
var cityPopulation: Int = 2_161_990
let cityAreaInKm2: Float = 10.82 // ya da Double
let isCapital: Bool = false
```

> Programlamada genel kabul ilk tanımlarken constant olarak tanımlayıp eğer
> sonradan değerini değiştiriyorsak normale çekmek yapmak yönünde. 

- Ekrana bir şey yazdırmak için `print()` ya da `println()` kullanabiliriz.
İki ekstra parametre kabul eder. `separator = " "` metinleri birleştiren, 
`terminator = "\n"` ise birleştirilmiş metnin sonuna koyulan karakterdir.

```swift
print("Selam.", "Ben Enes.", "23 yaşındayım. \n")
print("Selam.", "Ben Enes.", "23 yaşındayım.", separator: "\n", terminator: "THE END.")
```
<CodeResult>
Selam. Ben Enes. 23 yaşındayım. 

Selam.
Ben Enes.
23 yaşındayım.THE END.
</CodeResult>

- Değişkenleri string içerisinde yazdırmak için **String Interpolation**
kullanabiliriz.

```swift
let unluckiestTeamInWorld = "Fenerbahçe";
print("\(unluckiestTeamInWorld) dünyanın en şanssız takımıdır.")
```
<CodeResult>
Fenerbahçe dünyanın en şanssız takımıdır.
</CodeResult>

- **Array**'lerin tanımlanması ve elemanlarına erişilmesi klasik. Tip verirken iki
yolumuz var:

```swift
let oddNumbers: Array<Int> = [1, 3, 5, 7, 9, 11, 13, 15]
let evenNumbers: [Int] = [2, 4, 6, 8, 10, 12, 14, 16]
```

- **Set**, unordered ve tüm öğeleri benzersiz olan veri koleksiyonudur. Sıranın
korunmasının gerekmemesi hızlıca arama yapabilmemiz gibi ek faydalar sağlar.

```swift
let colors = Set(["red", "green", "blue"])
let colors2 = Set(["red", "green", "blue", "red", "blue"]) // red, green, blue
let colors3: Set<String> = ["red", "green", "blue"]
```

- **Tuple**, boyutu sabit veri koleksiyonudur. Öğe ekleyemeyiz ve silemeyiz.
korunmasının gerekmemesi hızlıca arama yapabilmemiz gibi ek faydalar sağlar.

```swift
var person: (String. Int, Bool) = (name: "Paul", age: 40, isMarried: true)
print(name.0)
print(name.name)

var product: (String. Int) = ("MacBook", 1099.99)
print(product.0)
print(product.1)
```

- **Dictionary**, key-value çiftlerini barındıran veri koleksiyonudur. Key yoksa
`nil` döner. Ve varsayılan değer tanımlayabiliriz.

```swift
let examResults = [
    "english": 100,
    "french": 85,
    "geography": 75
]

print(examResults["english"])
print(examResults["history"])
print(examResults["history", default: 0])
```

<CodeResult>
Optional(100)
nil
0
</CodeResult>

- Boş koleksiyonlar oluşturmak için tiplerini kullanabiliriz.

```swift
var results = [Int]()
var results2 = Array<Int>()

var words = Set<String>()

var scores = [String: Int]()
var scores = Dictionary<String, Int>()
```

- **Enumerations** ya da kısa ismiyle **Enums**, ilişkili değerleri gruplamanın
bir yoludur.

<CH.Code>

```swift example1
enum Direction {
    case north
    case south
    case east
    case west
}

let direction = Direction.south
```

```swift example2
enum Direction: Int {
    // default enum starts with 0. now starts with 1.
    case north = 1
    case south
    case east
    case west
}

let direction = Direction.south

print("Type direction:", type(of: direction)) // Direction
print("Direction:", direction) // south
print("Direction RawValue:", direction.rawValue) // 2
```
</CH.Code>

### Kaynaklar:
- [https://www.hackingwithswift.com/100/1](https://www.hackingwithswift.com/100/1)
- [https://www.hackingwithswift.com/100/2](https://www.hackingwithswift.com/100/2)
- [https://www.avanderlee.com/swift/array-vs-set-differences-explained/](https://www.avanderlee.com/swift/array-vs-set-differences-explained/)

## GÜN 2:

Operatörlere, koşullu ifadelere, döngülere ve fonksiyonlara girdim. Swift çok 
temiz bir dil. JS neymiş öyle arkadaş ya :D

### Notlarım:

- Swift, sayı değişkenleri arasındaki matematiksel işlemlerde otomatik tip
dönüştürmez.

```swift
let result = 2 + 1.0
print(result)

let num1: Int = 2
let num2: Double = 1.0
let result2 = num1 + num2
print(result2)
```
<CodeResult>
3.0
Error: binary operator '+' cannot be applied to operands of type 'Int' and 'Double'
</CodeResult>

- İki Int bölüyorsak sonuç otomatik sıfıra yuvarlanır. Engellemek için tip
atayabiliriz.

```swift
let result1 = 365 / 7
let result2: Double = 365 / 7
print("result1:", result1)
print("result2:", result2)
```
<CodeResult>
result1: 52
result2: 52.142857142857146
</CodeResult>

- String ve Array birleştirme işlemi `+` operatörüyle yapılabilir. Buna
**Operator Overloading** denir.

```swift
let fakers = "Fakers gonna "
let action = fakers + "fake"

let firstHalf = ["John", "Paul"]
let secondHalf = ["George", "Ringo"]
let beatles = firstHalf + secondHalf
```

- Enum değerlerini karşılaştırma operatörüyle kullanıma uygun hale getirebiliriz.

```swift
enum Sizes: Comparable {
    case small
    case medium
    case large
}

let first = Sizes.small
let second = Sizes.large
print(first < second)
```
<CodeResult>
true
</CodeResult>

- Ternary operatör JS'dekinin aynısı gibi uygulanabilir.

```swift
let firstCard = 11
let secondCard = 10
print(firstCard == secondCard ? "Cards are the same" : "Cards are different")
```
<CodeResult>
Cards are different
</CodeResult>

- Aynı şekilde klasik Switch yapısı da mevcut. Otomatik olarak her case'e
default ekler. Eğer eşleşen case'in altındakileri de çalıştırmak istersek
`fallthrough` keyword`ünü kullanabiliriz.

```swift
let weather = "sunny";

switch weather {
case "rain":
    print("Bring an umbrella")
case "snow":
    print("Wrap up warm")
case "sunny":
    print("Wear sunscreen")
    fallthrough
default:
    print("Enjoy your day!")
}
```
<CodeResult>
Wear sunscreen
Enjoy your day!
</CodeResult>

- Sayı aralıkları tanımlamak için `Range` sınıfı mevcuttur. Bu değişkenler
**range operator** ile oluşturulur. Üst limiti dahilse `...`, değilse `..<`
kullanabiliriz.

```swift
let names = ["Piper", "Alex", "Suzanne", "Gloria"]

print(names[1...2])
print(names[1..<2])
print(names[1...])
print(names[...2])
print(names[..<2])
print(names[...])
```
<CodeResult>
["Alex", "Suzanne"]
["Alex"]
["Alex", "Suzanne", "Gloria"]
["Piper", "Alex", "Suzanne"]
["Piper", "Alex"]
["Piper", "Alex", "Suzanne", "Gloria"]
</CodeResult>

```swift
let score = 85

switch score {
case 0..<50:
    print("You failed badly.")
case 50...85:
    print("You did OK.")
default:
    print("You did great!")
}
```
<CodeResult>
You did OK.
</CodeResult>

- Dizi üzerinde döngü kurmak istersek `for in` kullanabiliriz.

<CH.Code>

```swift example1
let albums = ["Red", "1989", "Reputation"]

for album in albums {
    print("\(album) is on Apple Music")
}
```

```swift example2
let count = 1...10

for number in count {
    print("Number is \(number)")
}
```

```swift example3
for _ in 1...5 {
    print("repeat")
}
```
</CH.Code>

- Do-while yapısına ihtiyacımız olursa `repeat` kullanabiliriz.

```swift
let numbers = [1, 2, 3, 4, 5]
var random: [Int]

repeat {
    random = numbers.shuffled()
} while random == numbers
```
<CodeResult>
1
</CodeResult>

- Döngülerden çıkmak için `break` kullanabiliriz. İç içe döngülerde tümünden
çıkmak istersek label verebiliriz.

```swift
let options = ["up", "down", "left", "right"]
let secretCombination = ["up", "up", "right"]

outerLoop: for option1 in options {
    for option2 in options {
        for option3 in options {
            print("Wrong combination!")
            let attempt = [option1, option2, option3]

            if attempt == secretCombination {
                print("\(attempt) is correct combination!")
                break outerLoop
            }
        }
    }
}
```
<CodeResult>
Wrong combination!
Wrong combination!
Wrong combination!
Wrong combination!
["up", "up", "right"] is correct combination!
</CodeResult>

- Fonksiyon tanımı için `func` keywordü kullanılır. Birden çok değer
döndüreceksek tuple kullanmak güzel bir tercih.

```swift
func square(number: Int) -> Int {
    return number * number
}

let result = square(number: 8)
print(result)
```
<CodeResult>
65
</CodeResult>

- Eğer fonksiyon bloğunda yalnızca return varsa kısaltabiliriz.

```swift
func square(number: Int) -> Int { number * number }

func greet(name: String) -> String { name == "" ? "Hello!" : "Hi, \(name)" }
```

- Fonksiyon parametrelerinde blok içinde ve çağrılırken kullanılacak iki isim
verebiliriz. Buna **label** denir. Varsayılan vermek JS ile aynı.

```swift
func setAge(for person: String, to value: Int = 0) {
    print("\(person) is now \(value)")
}

setAge(for: "Paul", to: 40) // set age for Paul to 40
```
<CodeResult>
Paul is now 23
</CodeResult>

- Fonksiyon çağırırken parametre adını atlamak istersek label olarak `_`
kullanabiliriz.

```swift
func greet(_ person: String) {
    print("Hello, \(person)!")
}

greet("Taylor")
```
<CodeResult>
Hello, Taylor!
</CodeResult>

- Aynı türden herhangi bir sayıda parametreyi kabul eden fonksiyonlara
`variadic func` denir.

```swift
func customPrint(_ texts: String...) {
    print(texts.joined(separator: " "))
}

func square(numbers: Int...) {
    for number in numbers {
        print("\(number) squated is \(number * number)")
    }
}

customPrint("Welcome", "to", "calculator!")
customPrint()
square(numbers: 1, 2, 3, 4, 5)
```
<CodeResult>
Welcome to calculator!

1 squared is 1
2 squared is 4
3 squared is 9
4 squared is 16
5 squared is 25
</CodeResult>

- Error Handling'i aşağıdaki biçimde gerçekleştirebiliriz. `Error` interface'inden türetilmiş enum kullanılarak `throw` ile hata
fırlatılır. Hatayı yakalamak için `do-cath` blokları kullanılır. Hata beklenen
fonksiyonun önüne `try` eklenir.

```swift
enum PasswordError: Error {
    case obvious
}


func checkPassword(_ password: String) throws -> Bool {
    if password == "password" {
        throw PasswordError.obvious
    }

    return true
}

do {
    try checkPassword("password")
    print("That password is good!")
} catch {
    print("You cant use that password!")
}
```
<CodeResult>
You cant use that password!
</CodeResult>

- Varsayılan olarak fonksiyon parametreleri constant'tır. Ancak in-place
değişiklik yapmak istersek `inout` keywordünü kullanabiliriz.

```swift
func doubleInPlace(number: inout Int) { number *= 2 }

var num = 10
doubleInPlace(number: &num)

print(num)
```
<CodeResult>
20
</CodeResult>

### Kaynaklar:
- [https://www.hackingwithswift.com/100/3](https://www.hackingwithswift.com/100/3)
- [https://www.hackingwithswift.com/100/4](https://www.hackingwithswift.com/100/4)
- [https://www.hackingwithswift.com/100/5](https://www.hackingwithswift.com/100/5)

## GÜN 3:

Bugün Closure'lardan devam ediyorum.

### Notlarım:

- Fonksiyonları değişkene atayabiliriz ve diğer fonksiyonlara iletebiliriz.
Bu tip fonksiyonlara **closure** denir.

```swift
let driving = {
    print("I'm driving in my car.")
}

func travel(action: () -> Void) {
    print("I'm getting ready to go.")
    action()
    print("I arrived!")
}

travel(action: driving)
```
<CodeResult>
I'm getting ready to go.
I'm driving in my car.
I arrived!
</CodeResult>

- Closure'lar parametreleri tuple tanımı ile karışmasını önlemek için parantez 
içinde kabul ederler. Fonksiyon gövdesinin başladığını belirtmek için de `in`
kullanılır. Çağrılırken parametre ismini kullanmazlar.

```swift
let payment = { () -> Bool in
    print("Paying an anonymous person…")
    return true
}

let drivingWithReturn = { (place: String) -> String in
    return "I'm going to \(place) in my car"
}
```

- Bir fonksiyonun son parametresi closure ise özel bir syntax ile yazabiliriz.
Başka parametre yoksa parantezleri uçurabiliriz.

```swift
func animate(duration: Double, animations: () -> Void) {
    print("Starting a \(duration) second animation…")
    animations()
}

animate(duration: 3) {
    print("Fade out the image")
}
```

- Parametre olarak iletilen Closure'ları daha da kısaltabiliriz. Zaten
fonksiyonda belirtildiği için tip belirtmeye gerek kalmaz. Aynı zamanda
parametreler indeksine göre kullanılabilir.

```swift
func travel(action: (String) -> String) {
    print("I'm getting ready to go.")
    let description = action("London")
    print(description)
    print("I arrived!")
}

travel { (place: String) -> String in
    return "I'm going to \(place) in my car"
}

travel { place in
    "I'm going to \(place) in my car"
}

travel {
    "I'm going to \($0) in my car"
}
```

- Fonksiyonlar return olarak closure döndürebilir.

```swift
func getIncrementer() -> (Int) -> Void {
    var count = 0
    
    return { step in
        count += step
        print(count)
    }
}

let incrementer = getIncrementer()
incrementer(5)
incrementer(2)
incrementer(3)
```
<CodeResult>
5
7
10
</CodeResult>

### Kaynaklar:
- [https://www.hackingwithswift.com/100/6](https://www.hackingwithswift.com/100/6)
- [https://www.hackingwithswift.com/100/7](https://www.hackingwithswift.com/100/7)

## GÜN 4:

Bugün Struct'lardan devam ediyorum.

### Notlarım:

- Swift'te kendi değişken türlerimizi oluşturmanın yollarından birisi
`struct`'tır. Kendi değişkenlerini işlevlerini saklayabilir. Barındırdığı
değişkenlere `property` denir. Değeri hesaplanması gerekiyorsa `computed`
propertydir.

```swift
struct Sport {
    var name: String
    var isOlympicSport: Bool = false
    
    var olympicStatus: String {
        if isOlympicSport {
            return "\(name) is an Olympic sport"
        } else {
            return "\(name) is not an Olympic sport"
        }
    }

    func startTournament() -> Bool {
        print("Tournament started!")
    }
}

let chessBoxing = Sport(name: "Chessboxing", isOlympicSport: false)
print(chessBoxing.olympicStatus)
```
<CodeResult>
Chessboxing is not an Olympic sport
</CodeResult>

- Property değerlerinin değişmesi sonucunda bir işlem yapmak isteyebiliriz.
Değişiklik öncesinde bir işlem yapmak için `willSet`, sonrasında yapmak için
`didSet` kullanabiliriz. Bu yapılara **property observer** denir.

```swift
struct Progress {
    var task: String
    var amount: Int {
        didSet {
            print("\(task) is now \(amount)% complete")
        }
    }
}

var progress = Progress(task: "Loading data", amount: 0)
progress.amount = 30
progress.amount = 80
progress.amount = 100
```
<CodeResult>
Loading data is now 30% complete
Loading data is now 80% complete
Loading data is now 100% complete
</CodeResult>

- Metodlardan property'leri değiştirebilmek için `mutating` keywordüyle
işaretlemeliyiz.

```swift
struct Person {
    var name: String

    mutating func makeAnonymous() {
        name = "Anonymous"
    }
}

var person = Person(name: "Ed")
person.makeAnonymous()
```

- Değişken türleri `struct` örnekleridir.
- Normalde propertyler **memberwise initializer** ile değer alır. Özel
**initializer** da tanımlayabiliriz.

```swift
struct User {
    var username: String

    init() {
        username = "Anonymous"
        print("Creating a new user!")
    }
}

var user = User()
```
<CodeResult>
Creating a new user!
</CodeResult>

- Objenin kendisine erismek icin `self` kullanılır. Burda self kullanmadan da
atama işlemini gerçekleştirebilirdik.

```swift
struct Person {
    var name: String
    
    init(name: String) {
        print("Hello \(name)")
        self.name = name
    }
}

struct PersonWithoutSelf {
    var name: String
    
    init(name studentName: String) {
        print("Hello \(name)")
        name = studentName
    }
}

Person(name: "Enes")
```
<CodeResult>
Hello Enes
</CodeResult>

- Performans olarak bir takım optimizasyon yapmak için `lazy` keywordünü
kullanabiliriz. Property'nin oluşturulması için ilk erişimi bekler.

```swift
struct FamilyTree {
    init() {
        print("Creating family tree!")
    }
}

struct Person {
    var name: String
    lazy var familyTree = FamilyTree()
    
    init(name: String) {
        print(name)
        self.name = name
    }
}

var ed = Person(name: "Enes")
print("Person created!")
ed.familyTree
```
<CodeResult>
Enes
Person created!
Creating family tree!
</CodeResult>

- Nesneler arası yani sınıfın propertysi tanımlamak için `static` kullanırız.

```swift
struct Student {
    static var classSize = 0
    var name: String

    init(name: String) {
        self.name = name
        Student.classSize += 1
    }
}

print(Student.classSize)
let student1 = Student(name: "Enes")
print(Student.classSize)
```
<CodeResult>
0
1
</CodeResult>

- Property ve metodlar için erişim yetkisi tanımlayabiliriz. `private` struct
dışına gizler, `public` ise erişime izin verir.

```swift
struct Person {
    private var id: String

    init(id: String) {
        self.id = id
    }

    func identify() -> String {
        return "My social security number is \(id)"
    }
}

let person = Person(id: "1")
// person.id'ye erişilemez.
print(person.identify())
```
<CodeResult>
My social security number is 1
</CodeResult>


### Kaynaklar:
- [https://www.hackingwithswift.com/100/8](https://www.hackingwithswift.com/100/8)
- [https://www.hackingwithswift.com/100/9](https://www.hackingwithswift.com/100/9)

## GÜN 5:

### Notlarım:
- Class'larda structan ayrı olarak memberwise initializer bulunmaz yani `init`
daima tanımlanmalı.

```swift
class Dog {
    var name: String
    var breed: String

    init(name: String, breed: String) {
        self.name = name
        self.breed = breed
    }
}
```

- Başka bir class'tan type atar gibi inheritance yapabiliriz. Miras alınan
**parent class** alan **child class** olarak isimlendirilir.

```swift
class Dog {
    var name: String
    var breed: String
    
    init(name: String, breed: String) {
        self.name = name
        self.breed = breed
    }
}


class Poodle: Dog {
    init(name: String) {
        super.init(name: name, breed: "Poodle")
    }
}
```

- Child class'tan parent class metodlarının implementasyonlarını
değiştirebiliriz. Buna `overriding` denir.

```swift
class Dog {
    func makeNoise() {
        print("Hav!")
    }
}

class Poodle:Dog {
    override func makeNoise() {
        print("Yip!")
    }
}

let anotherDog = Dog()
let poodle = Poodle()

anotherDog.makeNoise()
poodle.makeNoise()
```
<CodeResult>
Hav!
Yip!
</CodeResult>

- Inherit edilmemesini istediğimiz sınıfları `final` ile tanımlayabiliriz.

- Struct `value type`, class `reference type` dır. Dolayısıyla nesnelerinden
oluşturulan atamalar farklı davranır.

<CH.Code>
```swift class
class SingerClass {
    var name = "Taylor Swift"
}

let singer = SingerClass()
var singerCopy = singer
singerCopy.name = "Justin Bieber"
print(singer.name) // Justin Bieber
```

```swift struct
struct SingerClass {
    var name = "Taylor Swift"
}

let singer = SingerClass()
var singerCopy = singer
singerCopy.name = "Justin Bieber"
print(singer.name) // Taylor Swift
```
</CH.Code>

- Class'ta örnek destroy edildiğinde çalışan `deinitializer` yapısı vardır.

```swift
class Person {
    var name = "John Doe"

    init() {
        print("\(name) is alive!")
    }

    deinit {
        print("\(name) is dead!")
    }
}

for _ in 1...3 {
    let person = Person()
}
```
<CodeResult>
John Doe is alive!
John Doe is dead!
John Doe is alive!
John Doe is dead!
John Doe is alive!
John Doe is dead!
</CodeResult>

- Constant class örneğindeki property değerleri değiştirilebilir.
Değiştirilmesini engellemek için property `let` ile tanımlanmalı.

```swift
class Singer {
    var name = "Taylor Swift"
}

let taylor = Singer()
taylor.name = "Ed Sheeran"
print(taylor.name)
```

### Kaynaklar:
- [https://www.hackingwithswift.com/100/10](https://www.hackingwithswift.com/100/10)

## GÜN 5:

### Notlarım:
- `Protocol` nesnelerin hangi property ve methodlara sahip olması gerektiğini
tanımlar. Protocolde olmayan şeyler eklenebilir.

```swift
protocol Purchaseable {
    var name: String { get set }
}

struct Book: Purchaseable {
    var name: String
    var author: String
}

struct Movie: Purchaseable {
    var name: String
    var actors: [String]
}

struct Car: Purchaseable {
    var name: String
    var manufacturer: String
}

struct Coffee: Purchaseable {
    var name: String
    var strength: Int
}


func buy(_ item: Purchaseable) {
    print("I'm buying \(item.name)")
}
```

- Protocoller **protocol inheritance** ile miras alabilir.

<CH.Code>
```swift example1
protocol Payable {
    func calculateWages() -> Int
}

protocol NeedsTraining {
    func study()
}

protocol HasVacation {
    func takeVacation(days: Int)
}

protocol Employee: Payable, NeedsTraining, HasVacation { }
```

```swift example2
protocol Product {
    var price: Double { get set }
    var weight: Int { get set }
}

protocol Computer: Product {
    var cpu: String { get set }
    var memory: Int { get set }
    var storage: Int { get set }
}

protocol Laptop: Computer {
    var screenSize: Int { get set }
}
```
</CH.Code>

- Var olan tiplere method eklemek için `extension` yapısını kullanabiliriz.
Property eklemek için computed property olması gerekir.

```swift
extension Int {
    var isEven: Bool {
        return self % 2 == 0;
    }
    
    func squared() -> Int {
        return self * self
    }
}

let num1 = 14
num1.isEven
num1.squared()
```

```swift
extension String {
    var isLong: Bool {
        return count > 25 // propertyleri direk kullanabiliriz.
    }
}
```

- Birden çok türe aynı anda eklemek yapmak istersek `protocol extension`
uygulamamız gerekir. Hem array hem de set veri tipi `Collection` protocokolünden
çağırılırlar. Bu yüzden bu protokole bir şey eklersek ikisi de etkilenir.

```swift
extension Collection {
    func summarize() {
        print("There are \(count) of us:")

        for name in self {
            print(name)
        }
    }
}
```

- Protocol methodlarını miras alan nesnelerin her birinde tek tek tanımlamak
yerine protocol extension ile default tanımlayabiliriz.

```swift
protocol Identifiable {
    var id: String { get set }
    func identify()
}

extension Identifiable {
    func identify() {
        print("My ID is \(id).")
    }
}

struct User: Identifiable {
    var id: String
}

let twostraws = User(id: "twostraws")
twostraws.identify()
```

### Kaynaklar:
- [https://www.hackingwithswift.com/100/11](https://www.hackingwithswift.com/100/11)

## GÜN 6:

### Notlarım:

- Swiftte değeri olmayan değişkenler `nil` değerini alır. Bunlar isteğe `optional`
değişken olarak geçer. Bunu kullanmak istersek kontrol sağlamalıyız. Buna
`unwrapping` denir. En yaygın yolu da `if let` syntaxıdır.

```swift
var name: String? = nil

if let unwrapped = name {
    print("\(unwrapped.count) letters")
} else {
    print("Missing name.")
}
```

- `if let` alternatifi `guard let`'tir. Tek fark kod bloğunun devamında unwrapped
kullanılabilir. Kontrol başarısız olursa mevcut işlevden, döngüden veya koşuldan
çıkmak için kullanılır.

> `guard` aslında bir kod bloğunun çalıştırılmadan önce her şeyin doğru olduğu
> aksi takdirde return, throw vs ile bloktan çıkılması gereken durumlarda kullanılır.

```swift
func greet(_ name: String?) {
    guard let unwrapped = name else {
        print("You didnt provide a name!")
        return
    }
    
    print("Hello \(unwrapped)")
}
```

- Bazen Optional değerlerin boş olmadığından emin oluruz. Unwrapping yapmaya
zorlamak için `!` kullanabiliriz.

```swift
let names = ["Zoey", "Chloe", "Amani", "Amaia"]
let randomName = names.randomElement()! // return optional value
```

- Her yerde kullanmaktan ziyade tanımlarken de force unwrapping yapabiliriz. 
Değişkenin boş başlayacağı, ancak onu kullanmak istediğiniz zaman boş olmayacağı
durumlarda kullanışlıdır.

```swift
let age: Int! = nil
```

- Eğer değişken değeri `nil` ise başka değer vermek istersek
`nil coalescing operator` kullanabiliriz. Zincirleyebiliriz.

```swift
func username(for id: Int) -> String? {
    if id == 1 {
        return "Taylor Swift"
    } else {
        return nil
    }
}

let user = username(for: 15) ?? "Anonymous"
```

- Nesne propertylerine erişirken `nil` ile karşılaşırsak kodumuz hata verir.
Bunu engellemek için `optional chaining operator` kullanabiliriz. Eğer boş değer
gelirse geri kalanı çalıştırmadan `nil` döndürür.

```swift
let names = ["Vincent": "van Gogh", "Pablo": "Picasso", "Claude": "Monet"]
let surnameLetter = names["Vincent"]?.first?.uppercased() ?? "?"
```

- do-cath yapısını optional kontrolüyle birlikte de kullanabiliriz. Buna
`optional try` denir. Hem `nil` dönerse hem hata fırlatırsa else bloğuna girer.

```swift
do {
    try checkPassword("password")
    print("That password is good!")
} catch {
    print("You can't use that password.")
}

if let result = try? checkPassword("password") {
    print("That password is good!")
} else {
    print("You can't use that password.")
}
```

- Eğer struct ya da class'tan nesne oluştururken bazı caselerde boş değer vermek
istersek `failable initializer` kullanabiliriz.

```swift
struct Person {
    var id: String

    init?(id: String) {
        if id.count == 9 {
            self.id = id
        } else {
            return nil
        }
    }
}

let person = Person(id: "invalid") // nill
```

- Eğer inherited sınıflar arasında typecast yapmak istersek `as?` kullanabiliriz. Eğer
işlem başarısız olursa if let nil olacağından bloğu çalıştırmaz.

```swift
class Animal {}
class Fish: Animal {}
class Dog: Animal {
    func makeNoise() {
        print("Hav!")
    }
}

let pets = [Fish(), Dog(), Fish(), Dog()]

for pet in pets {
    if let dog = pet as? Dog {
        dog.makeNoise()
    }
}
```
 
### Kaynaklar:
- [https://www.hackingwithswift.com/100/12](https://www.hackingwithswift.com/100/12)
- [https://www.avanderlee.com/swift/guard-statements/](https://www.avanderlee.com/swift/guard-statements/)

<TheEnd />

Android geliştirme öğrenirken önemli gördüğüm noktalardan kesitleri bir yerde tutmak istedim. Yazıyı sürekli güncelliyor olacağım.

Sağlıcakla kalın.