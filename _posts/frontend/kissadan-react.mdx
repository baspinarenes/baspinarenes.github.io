---
title: "Kıssadan React [Yaşayan Yazı]"
date: 2022-12-12
summary: "React hakkında tuttuğum kısa notlar."
---

<WarningBox>
  **Yaşayan Yazı**, bir yerimden uydurduğum bir terimdir ve ileriki dönemde içeriği zenginleşecek ama şu anki haliyle de faydalı olabilecek yazıları belirtir.
</WarningBox>

Yeni React dökümantasyonunun çıkmasıyla birlikte baştan takip etmek istedim. Dolayısıyla sıfırdan öğrenen birisine yardımcı olacak kilit noktaları az ve öz paylaşıyor olacağım.

### Genel

- React'ın "Strict Mode"u development esnasında her komponent fonksiyonunu iki kez çağırır ve Pure olmayan komponentleri yakalamanızı sağlar.
- Animasyon ve ekranın yenilenmesi gibi işlemler **side effect** olarak adlandırılırlar. Renderlama anında değil yanında meydana gelen şeylerdir.

### Renderlama

- React komponentler esasen render edilmek üzere HTML döndüren fonksiyonlardır. Aslında HTML gibi dursa da JSX dediğimiz ve HTML çok benzeyen bir uzantı kullanır. Kendisi de JS olduğundan kodların elementlerle kullanılmasını kolaylaştırır. Nihayetinde kendisi de HTML'e çevrilir.

```javascript
function MyButton() {
  return (
    <button>I'm a button</button>
  );
}

export default function MyApp() {
  return (
    <div>
      <h1 className="heading-1">Welcome to my app</h1>
      <MyButton />
    </div>
  );
}
```

- Tek bir element/komponent döndürmesi gerekir. Eğer iç içe olmaması gereken bir şeyler varsa etrafına `<div>` ya da `<>` sarabiliriz.
```javascript
<div>
  <CustomElement />
  <div />
</div>
```

- Child komponenti yoksa her zaman kapanan etiket (closing tag) ile yazmalıyız.
```javascript
<CustomElement />
<div />
```

- Birden fazla element return edilemez. Bunları `<div>...</div>` ya da `<>...</>` etrafına sarmalıyız. İkincisinin adı **Fragment** olarak geçer ve HTML'e ekstra bir element eklemeden bu işi görür. Sebebi ise bir fonksiyonun array olmadığı takdirde birden fazla sonuç döndürememesidir.

```js
<div>
  <CustomElement />
  <div />
</div>
```

- JavaScript değişkenleri ve ifadelerini (expression) JSX'de süslü parantez ile kullanabiliriz.

```js
const user = {
  name: 'Hedy Lamarr',
  imageUrl: 'https://i.imgur.com/yXOvdOSs.jpg',
  imageSize: 90,
};

export default function Profile() {
  return (
    <>
      <h1>{user.name}</h1>
      <img
        className="avatar"
        src={user.imageUrl}
        alt={`Photo of ${user.name}`}
        style={{
          width: user.imageSize,
          height: user.imageSize
        }}
      />
    </>
  );
}
```

- Koşullu render için 3 farklı yaklaşım uygulayabiliriz. `false`, `null` ve `undefined` değerleri JSX'de gözardı edilir.

```js
let content;

if (isLoggedIn) {
  content = <AdminPanel />;
} else {
  content = <LoginForm />;
}
return (
  <div>
    {content}
  </div>
);
```

```js
<div>
  {isLoggedIn ? (
    <AdminPanel />
  ) : (
    <LoginForm />
  )}
</div>
```

```js
<div>
  {isLoggedIn && <AdminPanel />}
</div>
```

- Koşullu render yapmak istersek `condition ? result1 : result2` , `condition && result` şeklinde kısaltma ya da `if` koşulunu kullanabiliriz.

```javascript
if (isPacked) {
  return <li className="item">{name} ✔</li>;
}

return <li className="item">{name}</li>;
```
```javascript
return (
  <li className="item">
    {isPacked ? name + ' ✔' : name}
  </li>
);
```
```javascript
return (
  <li className="item">
    {name} {isPacked && '✔'}
  </li>
);
```

- Listeleri render etmek istersek array metodlarıyla ürettiğimiz JSX element 
element listesi kullanabiliriz. Burda dikkat edilmesi gereken listedeki 
değişikliklere adapte olabilmesi için elementlere `key` özelliği iletilmelidir. 
Aksi halde indeks değerleri kullanır ve elemanların sıraları değişirse ya da 
içlerinden birisi silinirse doğru şeyleri render edemez. 

> `key` olarak uuid üreten bir kütüphane yada apiden dönen id değerini kullanabilirsiniz. Aksi halde şu hatayı alırsınız: 'Warning: Each child in a list should have a unique “key” prop.'

> `key` özelliğine her seferinde rastgele değer üreten bir metod verilirse (örneğin Math.random) DOM'a her seferinde yeniden render edilir.

```js
const products = [
  { title: 'Cabbage', id: 1 },
  { title: 'Garlic', id: 2 },
  { title: 'Apple', id: 3 },
];

const listItems = products.map(product =>
  <li key={product.id}>
    {product.title}
  </li>
);

return (
  <ul>{listItems}</ul>
);
```

### Event Handler

- Olaylara tepki gösterecel fonksiyonlarımızın ismini elementlere iletebiliriz. Çağrı parantezlerini eklerseniz render edilirken fonksiyon tek sefer çağrılır. Varsayılan olarak fonksiyona `Event` nesnesi geçilir ancak ekstra veri göndermek istersek **arrow function** kullanabiliriz.

```js
function MyButton() {
  function handleClick() {
    alert('You clicked me!');
  }

  return (
    // <button onClick={(e) => handleClick(e)}>
    <button onClick={handleClick}>
      Click me
    </button>
  );
}
```

- Fonksiyon çağrılırsa rendering esnasında çalıştırılır.

```js
<button onClick={handleClick()}>
```

- Elementlerin beklediği event props isimlerinde `on`, handler isimlerinde `handle` ile başlamak yaygındır. Örn: `onMouseEnter={handleMouseEnter}` 
- Event propagation komponentlerde de geçerlidir. Örnekte önce button sonra div `onClick` metodu çağrılır. `onScroll` harici tüm olaylar yukarıya yayılır. Engellemek için `e.stopPropagation()` kullanılır.

```js
export default function Toolbar() {
  return (
    <div className="Toolbar" onClick={() => {
      alert('You clicked on the toolbar!');
    }}>
      <button onClick={() => {
        e.stopPropagation();
        alert('Playing!')  
      }}>
        Play Movie
      </button>
    </div>
  );
}
```

- Formun `onSubmit` olayı gibi bazı olaylar varsayılan tarayıcı davranışına sahiptir ve sizin kodunuzdan sonra çalıştırır. Bunu engellemek için `e.preventDefault` kullanabiliriz.
- Event handler'ları yukarıdan aşağıya doğru (capturing) çalıştırmak istersek `onClick` yerine `onClickCapture` kullanımını yapabiliriz.

```js
<div onClick={() => {
  alert('Call 1');
}}>
  <div onClickCapture={() => {
    alert('Call 2');
  }}>
    <div onClickCapture={() => {
      alert('Call 3');
    }}>
      Click!
    </div>
  </div>
</div>
```
<CodeResult>
Call 2
Call 3
Call 1
</CodeResult>



### Props

- Bileşenden bileşene veri aktarmak için `props` kullanırız. Klasik fonksiyona parametre geçme mantığı.

```js
function Avatar({ person, size = 100 }) {
  // ...
}

function Profile() {
  return (
    <div className="card">
      <Avatar
        person="Enes"
        size={80}
      />
    </div>
  );
}
```

- Children elementleri props'un `children` özelliğinden okuyabiliriz.

```js
function Heading({ children }) {
  return (
    <div className="heading">
      {children}
    </div>
  );
}

export default function Text() {
  return <Heading>Hello</Heading>;
}
```

### State

- Zamanla değişebilen ve ekranın güncellenmesine yol açacak değerler için  **state** değişkenlerini kullanırız. Bi nevi komponent bazlı bellektir. Render'lar arasında değeri korunur. 
- React'da state tanımlamak için `useState` hook'u kullanılır.

> React'da `use` ile başlayan fonksiyonlara `hook` diyoruz ve esasen React'ın özelliklerini kullanabilmemize yarıyorlar. Komponentlerin root'unda kullanılabilirler. Koşul ya da döngü içine kullanmamalıyız. Gerekiyorsa yeni bir bileşen oluşturabiliriz.

```js
import { useState } from 'react';

function MyButton() {
  // count: mevcut değer
  // setCount: değeri güncelleyecek fonksiyon
  // 0: ilk değer
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return (
    <button onClick={handleClick}>
      Clicked {count} times
    </button>
  );
}
```

- State setter çağırıldıktan sonra rerender tetiklenir ve yeni değer kullanılır.
- React Hook'ların değerlerini çağrılma sırasına göre anlar. Arka arkaya tanımladığımız state değerleri dizide tutulur ve okunacağı zamanda indeksi birer arttırarak okur. Bu sebeptendir ki sadece komponentin root'unda tanımlanmalıdır.
- Obje tutuyorsak spread kullanmayı unutmamalıyız.

```js
const [person, setPerson] = useState({
  name: 'Niki de Saint Phalle',
  artwork: {
    title: 'Blue Nana',
    city: 'Hamburg',
    image: 'https://i.imgur.com/Sd1AgUOm.jpg',
  }
});

function handleTitleChange(e) {
  setPerson({
    ...person,
    artwork: {
      ...person.artwork,
      title: e.target.value
    }
  });
}
```

- State güncelleme metodu çalıştığı anda değeri yenilemez. Örnekte üç kez çağırılan setNumber metoduyla birlikte son değerin 3 olmasını bekleyebiliriz ancak öyle olmaz. Her bir setter çalıştığında state değeri mevcuttaki değer yani 0'dır. Metod çalışmayı bitirdikten sonra rerender olur ve state değeri güncellenir. Komponent context'deki değeri elde etmek istersek parametre olarak güncel değeri alan **updater** fonksiyon verebiliriz.

```js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 1); // setNumber(0 + 1)
        setNumber(number + 1); // setNumber(0 + 1)
        setNumber(number + 1); // setNumber(0 + 1)
        // yeni değer sonraki rerender'da 1 olur.
      }}>+3</button>
      <button onClick={() => {
        setNumber(number => number + 1); // setNumber(0 + 1)
        setNumber(number => number + 1); // setNumber(1 + 1)
        setNumber(number => number + 1); // setNumber(2 + 1)
        // yeni değer sonraki rerender'da 3 olur.
      }}>+3</button>
    </>
  )
}
```