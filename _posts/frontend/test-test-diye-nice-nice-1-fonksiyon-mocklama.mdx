---
title: "Test Test Diye Nice Nice: Mocklama - 1"
date: 2022-10-20
summary: "Fonksiyonları test ederken bağımlı oldukları fonksiyonları nasıl mocklayabileceğimizi görelim."
---

## Bölümler

- Test Test Diye Nice Nice: Mocklama - 1 (Şu anda
buradasınız!)
- [Test Test Diye Nice Nice: Mocklama - 2](/blog/frontend/test-test-diye-nice-nice-2-modul-mocklama)

<CustomImage
  src="/images/post/frontend/test-test-diye-nice-nice-unit-test-mocking-1/001.jpeg"
  reference="https://techbeacon.com/app-dev-testing/test-automation-tools-8-trends-techniques-watch"
  width={800}
  height={375}
  fluid
  borderless 
/>

Yazıya geçmeden önce, seriye isim verirken esinlendiğim, üstat Aşık Veysel'in
muazzam türküsünü izninizle şuraya iliştirmek istiyorum.

<iframe 
  style={{borderRadius: 12}}
  src="https://open.spotify.com/embed/track/7KBwZWuhVfscYVgWMhazEW?utm_source=generator"
  width="100%"
  height={152}
  frameBorder="0"
  allowfullscreen=""
  allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"
  loading="lazy">
</iframe>

E-ticaret uygulamalarını düşünelim. Kullanıcılar ürünlerin bilgilerini 
görebilir, önerileri keşfedebilir, ürün satın alabilir, taksit yaptırabilir ve
daha nice işlem gerçekleştirebilir. Tüm bunların doğru çalıştığından emin olmak
yazılım geliştirme sürecinin önemli bir parçasıdır. Bunu gözardı ettiğimizde,
uygulamanın güvenilirliği düşer ve hataların düzeltilme maliyeti artar.
İşte bu noktada, kodlarımızın her bir senaryo karşısında beklediğimiz gibi 
davrandığından emin olmak isteriz. Ancak bunu test etmek her zaman kolay olmaz.

## Mock Nedir ve Hangi Problemi Çözer?

İndirimi olan bir ürünün fiyatının doğru gösterilip gösterilmediğini test etmek 
istediğimizi varsayalım. API, testi yazdığım esnada bana indirimli ürün 
döndürüyor olabilir ve yazdığımız test geçebilir. Ancak ertesi gün 
indirimli ürün olacağının garantisi yoktur. İşte o an geldiğinde hapı yutarız, 
test kalır. Dolayısıyla işimizi şansa bırakmayıp ihtiyacımız olan verileri 
barındıran sahte bir ürün oluşturabiliriz ve API'den ürünü içeren response'un 
döndüğünü varsayabiliriz. Artık testimiz dış etkenlerden bağımsız hale gelir. 
Yüzlerce datayı çekmesini bekleyip hiç birisinde indirim olmadığını görseydik 
elimiz ayağımız titrerdi. Böylece testimiz kırılganlıktan kurtulmuş olur.

İşte sahte veri dediğimiz anda da mock kavramı hayatımıza girer. Esasen 
**mock**, yazılımdaki herhangi bir şeyin taklididir. Mocklamayı hayatla 
bağdaştıracak olursak **empatiye** benzetebiliriz. Normalde bir olay karşısında 
göstereceğimiz tavrı, empati kurarak sanki birisinin yerindeymiş gibi verebiliriz. Empati yapacağımız kişinin verdiği karara varırken hangi süreçlerden geçtiğini bilmeyiz ancak göstereceği tavrı bilebiliriz. Dolayısıyla düşünce sürecinden bağımsız olarak ne cevap vereceğine odaklanırız.

Felsefeyi bırakıp kodlamaya dönersek fonksiyonları mocklamadaki amaç fonksiyonun lojiğini gözardı edip değer döndürmeye zorlamaktır. Bazen statik değer döndürürüz bazen de gönderilen argümana göre dinamik bir değer.

<CustomImage
  src="/images/post/frontend/test-test-diye-nice-nice-unit-test-mocking-1/002.png"
  width={996}
  height={ 383}
  fluid
  borderless
/>

Yukarıdaki akışı gerçek verilerle test ettiğimizi ve herhangi bir kullanıcı gibi davrandığımızı yani ürünü sepete ekleyip ödeme işlemini yaptığımızı düşünelim. Checkout servisimize sonrasında da banka servisine ödeme isteğimizi iletiyoruz. Hesabımızdan paralarımız uçup gidiyor. Ödeme satıcıya düştükten sonra iptal edip bir süre bekledikten sonra paramıza kavuşuyoruz. Ve bunu binlerce kez gerçekleştiriyoruz, bankaya binlerce ödeme isteği atıyoruz. Adamlar DDoS yiyoruz diye alarmları yaktılar bile. Oluşacak karmaşayı bir düşünsenize. Bunun yerine daha kendi API'mize istek attığımız fonksiyonu sahtesiyle değiştirerek bu kargaşayı ortadan kaldırabiliriz. Ne satıcıyı sinirlendirmiş oluruz ne de bankaları.

## Mock Türleri

Test ile yeteri kadar uğraştıysanız mock yerine stub, mock, fake, dummy gibi bir sürü kelime kullanıldığına denk gelmişsinizdir. **Gerard Meszaros** kitabında bu kargaşayı önlemek için gerçek nesnenin yerine konulacak sahte nesneye **Test Double** yani test dublörü kavramını kullanıyor. Oyuncuların yerine geçen dublörler gibisine. Test dublörünü de altı kategoriye ayırıyor:

- **Dummy**: Fonksiyona geçmemiz gereken parametreleri doldurmak için verilir 
  ancak gerçekte kullanılmaz.
- **Fake**: Kodun basitleştirilmiş ancak çalışan bir halini içerir. Buna 
  verebileceğimiz örnek şifrelerin hashlerini almak için veritabanına gitmek 
  yerine test verisi tutan bir nesneden okumak ya da gerçek API yerine sahte 
  bir ödeme sistemi mekanizması kurmak.
- **Stub**: Test sırasındaki fonksiyon çağrılarında planlanmış yanıtlar 
  döndürmek için kullanılır. İlk çağrıldığında A sonucunu ikincisinde B 
  sonucunu diğerlerinde C sonucunu döndür diyebiliriz.
- **Spy**: Fonksiyonların kaç kez çağrıldığı, hangi parametreler ile çağrıldığı 
  ve ne cevaplar döndüğü gibi ekstra bilgileri kaydeder.
- **Mock**: Belirli argümanlarla çağrılmasını beklediğimiz fonksiyonların ne    
  cevap döndüreceğine
  planlamak için kullanılır. Beklenmedik argümanlarla çağrıldığında hata 
  fırlatır.

**Gerard Meszaros** reis bunu diyedursun biz **mock** diye genelliyor olacağız. 
Bazen de detaylar kafa bulandırır. Hem de kütüphanelerde bu tanımlar iç içe 
geçmiş vaziyettedirler.

## Fonksiyon Mocklama

### Girizgah

Bir fonksiyonu mocklarsak yani yerine sahte bir fonksiyon koyarsak normal 
fonksiyonlardan farklı olarak kaç kez ve hangi parametrelerle çağırıldığının 
kaydını tutabiliriz, döndüreceği değerleri belirtebiliriz. Jest kısmına 
geçmeden önce son olarak bir fonksiyonun mocklandıktan sonra nasıl 
gözükebileceğini görselleştirelim.

> Bana mocklanan bir metodun resmini çizebilir misin Abidin?

Bir ürünün bilgisini almak için API'ye istek atan yardımcı fonksiyonumuz olsun.

```javascript
const axios = require("axios");

async function getProduct(productId) {
  const response = await axios.get(
    `https://dummyjson.com/products/${productId}`
  );

  return response.data;
}
```

API'den dönecek değeri sahtesiyle değiştirmek yani mock'lamak istersek 
ilgili metodu implementasyonunu gözardı edecek şekilde yeniden tanımlayabiliriz.

```javascript focus=3:25
const axios = require("axios");

axios.get = () => {
  return {
    data: {
      id: 1,
      title: "iPhone 9",
      description: "An apple mobile which is nothing like apple",
      price: 549,
      discountPercentage: 12.96,
      rating: 4.69,
      stock: 94,
      brand: "Apple",
      category: "smartphones",
      thumbnail: "https://dummyjson.com/image/i/products/1/thumbnail.jpg",
      images: [
        "https://dummyjson.com/image/i/products/1/1.jpg",
        "https://dummyjson.com/image/i/products/1/2.jpg",
        "https://dummyjson.com/image/i/products/1/3.jpg",
        "https://dummyjson.com/image/i/products/1/4.jpg",
        "https://dummyjson.com/image/i/products/1/thumbnail.jpg",
      ],
    },
  };
};

async function getProduct(productId) {
  const response = await axios.get(
    `https://dummyjson.com/products/${productId}`
  );

  return response.data;
}
```

Yani ilgili metodu ezeriz tıpkı ünlü Türk kimyager Abuzer Kömürcü'nün de dediği 
gibi:

<iframe width="560" height="515" src="https://www.youtube.com/embed/hDaVN_Blv9s" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

İşte bundan sonra bahsedeceğimiz mesele temelinde budur. Peki neden gerçek 
değerler yerine sabit bir şey döndürmek isteyelim ki?

%95 indirime giren ürünlerde kullanıcının dikkatini çekebilmek için "Büyük 
Fırsat" rozeti koymak istediğimizi varsayalım. Bu kıyamet senaryosunda 
karşımıza çıkabilecek bir durum değil mi? Hayatınızda nerede gördüğünüzü 
hatırlamayı deneyin. Dolayısıyla veri bulmak zor olacaktır. Test etmek 
için aylarca bir satıcının bu oranda indirim yapmasını mı bekleyeceğiz yoksa 
satıcıya test etmek adına ricada mı bulunacağız? Tabii ki ikiside değil. Bu 
gibi durumlarda test etmek istediğimiz verilere sahip sahte bir tane oluşturur 
ve testi onunla yaparız.

### Uygulama

Nihayet Jest'e geldik. Mock yani sahte fonksiyon oluşturmak için `jest.fn
(implementation?)` metodunu kullanırız. İsteğe bağlı bir parametre alır ve bu 
parametre fonksiyonun implementasyonudur. Implementasyon derken de fonksiyon 
lojiğinden bahsediyoruz. Örnek vermek gerekirse `const func = () => {...}` daki `() => {...}` kısmı bu fonksiyonun implementasyonudur.

```javascript
const mockFunction = jest.fn();
console.log(mockFunction)
```
<CodeResult>
mockFunction [Function: mockConstructor] \{
`  _isMockFunction: true,`
`  getMockImplementation: [Function (anonymous)],`
`  mock: [Getter/Setter],`
`  mockClear: [Function (anonymous)],`
`  mockReset: [Function (anonymous)],`
`  mockRestore: [Function (anonymous)],`
`  mockReturnValueOnce: [Function (anonymous)],`
`  mockResolvedValueOnce: [Function (anonymous)],`
`  mockRejectedValueOnce: [Function (anonymous)],`
`  mockReturnValue: [Function (anonymous)],`
`  mockResolvedValue: [Function (anonymous)],`
`  mockRejectedValue: [Function (anonymous)],`
`  mockImplementationOnce: [Function (anonymous)],`
`  withImplementation: [Function: bound withImplementation],`
`  mockImplementation: [Function (anonymous)],`
`  mockReturnThis: [Function (anonymous)],`
`  mockName: [Function (anonymous)],`
`  getMockName: [Function (anonymous)]`
\}
</CodeResult>

Mocklamak istediğimiz metodları ise sahte fonksiyonlar ile değiştiririz. 
Dolayısıyla yukarıdaki gözlem esnasındaki örneğimizdeki gibi Axios'un `get()` 
metodunu mocklamak istersek:

```javascript
const axios = require("axios");

const mockAxiosGet = jest.fn();
axios.get = mockAxiosGet;
```

Aklınızda implementasyonu assign etmek yerine mock fonksiyon assign etmenin 
farkı nedir diyorsanız özelliklerini gördükten sonra cevap bulacaksınız.

#### .mock Niteliği

Mocklanmış fonksiyonlar, testlerde kullanabilmemiz için ekstra bilgiler 
depolarlar. Bunlara `mock` özelliği ile erişebiliriz. Niteliklerine bakacak olursak:
- `mock.calls` - Fonksiyonun çağrıldığı argümanları listeler. Dizinin her elemanı bir çağrıya karşılık gelir.
- `mock.results` - Fonksiyon çağrılarının sonucunu listeler. Dönüş türü, **return**, **throw** ya da **incomplete** olabilir.
- `mock.instances` - Fonksiyon constructor ise üretilen nesneleri listeler.
- `mock.contexts` - Fonksiyon çağrıldığı andaki **this** nesnelerini listeler.
- `mock.lastCall` - Son çağrının argümanlarını gösterir.

```javascript
function manipulateArray(array, manipulateMethod) {
  return array.map((item) => manipulateMethod(item));
}

test("playground", () => {
  const array = [0, 1, 2]
  const mockManipulateMethod = jest.fn((x) => x + 2);
  manipulateArray(array, mockManipulateMethod);

  console.log(
    "mockManipulateMethod's mock property:",
    mockManipulateMethod.mock
  );
});
```
<CodeResult>
`mockManipulateMethod's mock property: {`
`  "calls": [[0], [1], [2]],`
`  "contexts": [null, null, null],`
`  "instances": [null, null, null],`
`  "results": [`
`    { "type": "return", "value": 2 },`
`    { "type": "return", "value": 3 },`
`    { "type": "return", "value": 4 },`
`  ],`
`  "lastCall": [2]`
`}`
</CodeResult>

#### Statik Değer Döndürme

Mock fonksiyonunu sabit bir değer döndürmeye zorlamak için iki farklı metoda 
sahibiz:
- `mockReturnValue(value)` - Tüm çağrılışlarında döndürülecek değeri belirler. 
- `mockReturnValueOnce(value)` - Tek seferliğine döndürülecek değeri belirler.

```javascript
test("playground", () => {
  const mockFunction = jest
    .fn()
    .mockReturnValue("other calls")
    .mockReturnValueOnce("first call")
    .mockReturnValueOnce("second call");

  for (let index = 0; index < 5; index++) {
    console.log("mockedProduct", mockFunction());
  }
});
```
<CodeResult>
mockedProduct first call
mockedProduct second call
mockedProduct other calls
mockedProduct other calls
mockedProduct other calls
</CodeResult>

İki farklı örneğe daha bakalım. 

İlkinde `localStorage`'den değer okumak için bir fonksiyonumuz olsun. `key` verdiğimizde doğru `value` döndürüp döndürmeyeceğini test etmek için `window.localStorage.getItem()` metodunu mocklayacağız.

İkinci örneğimizde ise gelecekteki bir tarihe kalan süreyi hesaplamak 
istiyoruz. Eğer dokunmazsak mevcut tarihi verdiğimiz değerle test eder. Zamanın 
akışına kapılıp verdiğimiz bitiş tarihi geçtiğimizde test istediğimiz sonucu vermeyecek ve patlamalar başlayacaktır. İşte bu sebeple `new Date()`'in döndüreceği değeri mocklayıp bitiş tarihinden önce olduğundan emin olacağız.

> **Minik Not**: Örnekler arasında gezmek için tablere tıklayabilirsiniz.

<CH.Code>
```javascript example-1
function getFromLocalStorage(key) {
  return window.localStorage.getItem(key);
}

test("should get data from local storage correctly", () => {
  const key = "testKey";
  const value = "testValue";
  // mock fonksiyonunu oluşturalım.
  const mockLocalStorageGet = jest.fn();

  // window.localStorage.getItem'a mock fonksiyonu atayalım.
  // böylece test etmek için istediğimiz değeri döndürebiliriz.
  Object.defineProperty(window, "localStorage", {
    value: {
      getItem: mockLocalStorageGet,
    },
  });

  // window.localStorage.getItem çağrıldığında "testValue"
  // döndürmesini istiyoruz. burada mock fonksiyonu da mockladığımız
  // fonksiyonu da kullanabiliriz. 
  // örn: window.localStorage.getItem.mockReturnValue(value);
  mockLocalStorageGet.mockReturnValue(value);
  // artık test edeceğimiz fonksiyonu çağıralım.
  getFromLocalStorage(key);

  // fonksiyonun mocklanıp mocklanmadığına bakalım.
  expect(jest.isMockFunction(window.localStorage.getItem)).toBe(true)
  // window.localStorage.getItem "testKey" ile çağırıldı mı diye
  // kontrol edelim.
  expect(mockLocalStorageGet.mock.lastCall[0]).toBe(key);
  // window.localStorage.getItem "testKey" ile çağırıldında
  // belirlediğimiz değeri dönüyor mu diye kontrol edelim.
  expect(mockLocalStorageGet.mock.results[0].value).toBe(value);
});
```
```javascript example-2
function getRemainingTime(endDate, startDate = new Date()) {
  let delta = (endDate - startDate) / 1000;

  return {
    remainingDays: Math.floor(delta / (60 * 60 * 24)),
    remainingHours: Math.floor((delta / (60 * 60)) % 24),
    remainingMinutes: Math.floor((delta / 60) % 60),
    remainingSeconds: Math.floor(delta % 60),
  };
}

test("should return remaining data when give future date", () => {
  const endDate = new Date(2023, 1, 1);
  // new Date() ile döndürülecek değeri belirleyelim'.
  const mockCurrDate = new Date(2022, 10, 16, 16, 9, 25);
  // Date constructor'ından oluşacak nesnenin mockCurrDate
  // olmasını sağlayalım.
  global.Date = jest.fn().mockReturnValue(mockCurrDate);

  expect(getRemainingTime(endDate)).toEqual({
    remainingDays: 76,
    remainingHours: 7,
    remainingMinutes: 50,
    remainingSeconds: 35,
  });
});
```
</CH.Code>

Bu arada dikkatinizi çekmek istiyorum. Test etmek istediğim fonksiyonun 
içerisinde dış bir kaynaktan gelen diğer fonksiyonları (bizim ya da kütüphane 
fonksiyonu olması farketmez) mocklamalıyız. Doğru cevap döndüreceklerini kabul ederek ilerliyoruz. O metodların kendi testleri olmalıdır.

#### Dinamik Değer Döndürme

Fonksiyonları statik değer döndürmeye zorladık. Argümanlarına göre dinamik değer
döndürmekte isteyebiliriz. Bunun için mock fonksiyonumuza implementasyon tanımlayabileceğimiz üç metodumuz var:
- `mockImplementation(func)` - Tüm çağrılışlarında kullanılacak implementasyonu belirler. 
- `mockImplementationOnce(func)` - Tek seferliğine kullanılacak implementasyonu belirler. 
- `withImplementation(func, callback)` - Verilen callback fonksiyonun scope'u içerisinde çağırıldığında döneceği değeri belirler. 

```javascript
function manipulateArray(array, manipulateMethod) {
  return array.map((item) => manipulateMethod(item));
}

test("playground", () => {
  const array = [0, 1, 2];
  const manipulateMethod = jest.fn().mockImplementation((x) => x + 2);
  manipulateArray(array, manipulateMethod);

  console.log(manipulateMethod.mock.results);
});
```
<CodeResult>
`[`
`  { type: 'return', value: 2 },`
`  { type: 'return', value: 3 },`
`  { type: 'return', value: 4 }`
`]`
</CodeResult>

```javascript
test("playground", () => {
  const mockMethod = jest.fn(() => 'outside callback');

  console.log(mockMethod());

  mockMethod.withImplementation(
    // mockMethod implementasyonu belirtir.
    () => 'inside callback', 
    // implementasyon sadece bu fonksiyon kapsamında geçerli olur.
    () => {
      console.log(mockMethod());
    },
  );

  console.log(mockMethod());
});
```
<CodeResult>
outside callback
inside callback
outside callback
</CodeResult>

#### Mock Verilerini Temizleme

Bazen kompleks metodların farklı durumlarda vereceği cevabı kontrol etmek 
için birden fazla test yazarız. Ancak sorun şudur ki Jest bu metodların mock 
kayıtlarını varsayılan olarak temizlemez. Dolayısıyla eğer bir durumda 
fonksiyonun 2 kez çağrılmasını bekliyorsak daha fazla sayıda çağrılmasına 
denk gelebiliriz. Örneğin:

```javascript
describe("playground test suite", () => {
  const mockFunction = jest.fn().mockReturnValue("placeholder");

  test("test 1", () => {
    for (let index = 0; index < 2; index++) {
      console.log("mockFunction() result: ", mockFunction());
    }

    console.log(mockFunction.mock.calls.length);
  });

  test("test 2", () => {
    for (let index = 0; index < 2; index++) {
      console.log("mockFunction() result: ", mockFunction());
    }

    console.log(mockFunction.mock.calls.length);
  });
});
```
<CodeResult>
mockFunction() result:  placeholder
mockFunction() result:  placeholder
2
mockFunction() result:  placeholder
mockFunction() result:  placeholder
4
</CodeResult>

Test 2'de çağrılma sayısını test etmek isteseydik dört almamızla birlikte test 
hatalı olurdu. Halbuki diğer testleri etkilememeleri için mocklama kayıtlarının 
test bazlı olmalarını isteriz. Bunun için üç farklı metodumuz var:

- `mockClear()` - `.mock` özelliğindeki verileri temizler.
- `mockReset()` - `mockClear()` metodunun yaptıklarını yapar. Ek olarak
  mockReturnValue türevi fonksiyonların dönmeye zorladığı değerleri ve
  mockImplementation türevi fonksiyonların tanımladığı implementasyonları
  temizler.
- `mockRestore()` - `mockReset()` metodunun yaptıklarını yapar. Ek olarak mock 
  `jest.spyOn()` (**Spy** başlığı altında değineceğiz) ile oluşturulduysa, 
  orjinal implementasyonunu geri 
  yükler yani direk mocku temizler.

Bunları genellikle `afterEach` ile birlikte kullanmayı tercih ederiz. 
Böylece her testten önce mock verilerinin temizlendiğinden emin oluruz.

```javascript
describe("playground suite", () => {
  const mockFunction = jest.fn().mockReturnValue("placeholder");

  afterEach(() => {
    mockFunction.mockReset();
  });

  test("playground 1", () => {
    for (let index = 0; index < 2; index++) {
      console.log("mockFunction() result: ", mockFunction());
    }

    console.log(mockFunction.mock.calls.length);
  });

  test("playground 2", () => {
    for (let index = 0; index < 2; index++) {
      console.log("mockFunction() result: ", mockFunction());
    }

    console.log(mockFunction.mock.calls.length);
  });
});
```
<CodeResult>
mockFunction() result:  placeholder
mockFunction() result:  placeholder
2
mockFunction() result:  undefined
mockFunction() result:  undefined
2
</CodeResult>

Bu örnekte yalnızca bir fonksiyonun mockunu temizledik. O ana kadar yapılan 
tüm mockları temizlemek istersek `jest.clearAllMocks()`,
`jest.resetAllMocks()` ve `jest.restoreAllMocks()` kullanabiliriz. 

Sürekli `afterEach()` yazıp durmak istemiyorsak da `jest.config.js` 
dosyasında her testten önce otomatik olarak çalışacak şekilde
aktifleştirebiliriz.

```javascript jest.config.js
export default {
  //...
  clearMocks: false,
  resetMocks: false,
  restoreMocks: false,
  //...
};
```

#### Asenkron Fonksiyonları Mocklama

Asenkron fonksiyonlar bildiğimiz gibi **Promise** döndürürler. Dolayısıyla 
asenkron fonksiyon mockladığımızda da döndüreceği değerin Promise olmasını 
bekleriz. Şu ana kadar gördüğümüz `mockImplementation()` metoduyla bunu
`jest.fn().mockImplementation(() => Promise.resolve(value));` ya da 
`jest.fn().mockImplementation(() => Promise.reject(value));` olacak şekilde 
yapabiliriz. Ancak Jest bu implementasyonları abstract eden dört metod sağlar:
- `mockResolvedValue(value)` - Tüm çağrılarda resolve edilmiş sonuç döndürür.
- `mockResolvedValueOnce(value)` - Tek seferliğine resolve edilmiş sonuç döndürür.
- `mockRejectedValue(value)` - Tüm çağrılarda reject edilmiş sonuç döndürür.
- `mockRejectedValueOnce(value)` - Tek seferliğine reject edilmiş sonuç döndürür.

```javascript
const axios = require("axios");

async function getProduct(productId) {
  try {
    const response = await axios.get(
      `https://dummyjson.com/products/${productId}`
    );

    return response.data;
  } catch (error) {
    return null;
  }
}

describe("getProduct tests", () => {
  beforeEach(() => {
    axios.get = jest.fn();
  });

  afterEach(() => {
    axios.get.mockReset();
  });

  test("should be return product data when request is succesfully", async () => {
    const mockedValue = {
      data: {
        id: 1,
        title: "iPhone 9",
        description: "An apple mobile which is nothing like apple",
        price: 549,
        discountPercentage: 12.96,
        rating: 4.69,
        stock: 94,
        brand: "Apple",
        category: "smartphones",
        thumbnail: "https://dummyjson.com/image/i/products/1/thumbnail.jpg",
        images: [
          "https://dummyjson.com/image/i/products/1/1.jpg",
          "https://dummyjson.com/image/i/products/1/2.jpg",
          "https://dummyjson.com/image/i/products/1/3.jpg",
          "https://dummyjson.com/image/i/products/1/4.jpg",
          "https://dummyjson.com/image/i/products/1/thumbnail.jpg",
        ],
      },
    };
    axios.get.mockResolvedValue(mockedValue);

    const result = await getProduct();

    expect(result).toStrictEqual(mockedValue.data);
  });

  test("should be return product data when request is failed", async () => {
    axios.get.mockRejectedValue(new Error("Error occured when fetching data!"));

    const result = await getProduct();

    expect(result).toStrictEqual(null);
  });
});

```
<CodeResult>
PASS  src/tests/getProduct.test.js
`  getProduct tests`
`    ✓ should be return product data when request is succesfully (20 ms)`
`    ✓ should be return product data when request is failed (1 ms)`
</CodeResult>

### Spy

Eveeet. Şu ana kadar fonksiyonlarımızı `jest.fn()` ile mockladık. Ancak ikinci 
bir yöntem daha var: `jest.spyOn(object, methodName)`. Peki bunun farkı ne ola 
ki?

**Spy**, varsayılan olarak fonksiyonun varolan implementasyonunu kullanır yani 
fonksiyonun implementasyonunu silmez. Bununla birlikte `jest.fn()` de olduğu 
gibi fonksiyon çağrılarına dair detayları gözlemleyebilmemizi sağlar. Dönüş 
değeri yine mock fonksiyonudur ve dolayısıyla şu ana kadar bahsettiğimiz tüm 
metodları kullanabiliriz.

Karşılaştırabilmek için `jest.fn()` çıktısını tekrar görelim.

```javascript
test("playground", () => {
  global.Date.now = jest.fn();

  console.log("First call return value:", Date.now());
  console.log("Second call return value:", Date.now());
  console.log("\nMocked function content:", Date.now);
});
```
<CodeResult>
`First call return value: undefined`
`Second call return value: undefined`

`Mocked function content: [Function: mockConstructor] {`
`  _isMockFunction: true,`
`  getMockImplementation: [Function (anonymous)],`
`  mock: [Getter/Setter],`
`  mockClear: [Function (anonymous)],`
`  mockReset: [Function (anonymous)],`
`  mockRestore: [Function (anonymous)],`
`  mockReturnValueOnce: [Function (anonymous)],`
`  mockResolvedValueOnce: [Function (anonymous)],`
`  mockRejectedValueOnce: [Function (anonymous)],`
`  mockReturnValue: [Function (anonymous)],`
`  mockResolvedValue: [Function (anonymous)],`
`  mockRejectedValue: [Function (anonymous)],`
`  mockImplementationOnce: [Function (anonymous)],`
`  withImplementation: [Function: bound withImplementation],`
`  mockImplementation: [Function (anonymous)],`
`  mockReturnThis: [Function (anonymous)],`
`  mockName: [Function (anonymous)],`
`  getMockName: [Function (anonymous)]`
`}`
</CodeResult>

Göreceğimiz üzere return değerlerinde sonucunda `undefined` aldık. Çünkü 
`jest.fn()` bir fonksiyona atandığı anda orjinal lojiği siler. Dolayısıyla 
fonksiyonun içi boş olduğu için değer dönemez. Dönmesini istersek 
implementasyon ya da mock değer belirtmek durumundayız. Bir de rakibine göz 
atalım.

```javascript
test("playground", () => {

  // ilk değer mocklayacağımız metodun ait olduğu nesnedir.
  // ikinci değer ise mocklamak istediğiniz metodun ismidir.
  jest.spyOn(global.Date, "now");

  console.log("First call return value:", Date.now());
  console.log("Second call return value:", Date.now());
  console.log("\nMocked function content:", Date.now);
});
```
<CodeResult>
`First call return value: 1665948858783`
`Second call return value: 1665948858785`

`Mocked function content: [Function: mockConstructor] {`
`  _isMockFunction: true,`
`  getMockImplementation: [Function (anonymous)],`
`  mock: [Getter/Setter],`
`  mockClear: [Function (anonymous)],`
`  mockReset: [Function (anonymous)],`
`  mockRestore: [Function (anonymous)],`
`  mockReturnValueOnce: [Function (anonymous)],`
`  mockResolvedValueOnce: [Function (anonymous)],`
`  mockRejectedValueOnce: [Function (anonymous)],`
`  mockReturnValue: [Function (anonymous)],`
`  mockResolvedValue: [Function (anonymous)],`
`  mockRejectedValue: [Function (anonymous)],`
`  mockImplementationOnce: [Function (anonymous)],`
`  withImplementation: [Function: bound withImplementation],`
`  mockImplementation: [Function (anonymous)],`
`  mockReturnThis: [Function (anonymous)],`
`  mockName: [Function (anonymous)],`
`  getMockName: [Function (anonymous)]`
`}`
</CodeResult>

Dönüş değerlerinin olduğunu çünkü implementasyonu biz istemedikçe silmediğini 
görebiliriz. Dönüş değeri `jest.fn()` ile aynı olduğu için bahsettiğimiz tüm 
metodlar kullanılabilir vaziyettedir. 

> Hangisini kullanacağınız konusunda kafanız karıştıysa özet geçelim. 
> Eğer bir fonksiyonun sadece kaç kez ve hangi parametrelerle çağrıldığını 
> izlemek istiyorsak ve bunları yaparken de lojiğini bozmak istemiyorsak 
> `jest.fn()` yerine `jest.spyOn()` kullanabiliriz. Aksi durumda hangisini
> seviyorsak yardırabiliriz.

Bu arada mock metodlarımızı üç farklı şekilde kullanabiliriz:
- Spy üzerinden: `jest.spyOn(global.Date, "now").mockImplementation(() => {});`
- Atadığımız değişken üzerinden: `spyDateNow.mockImplementation(() => {});`
- Mockladığımız metod üzerinden: `global.Date.now.mockImplementation(() => {});`

`spyOn()` ile mock fonksiyona nasıl implementasyon tanımlayacağımıza bakalım ve 
de zamanı gelmişken `mockRestore` ile nasıl çalıştığını görmüş olalım:

```javascript
test("playground", () => {
  jest.spyOn(global.Date, "now");
  console.log("First call return value: ", Date.now());
  
  global.Date.now.mockImplementation(() => "Hacked by Ayyıldız Team!");
  console.log("Second call return value: ", Date.now());
  
  global.Date.now.mockRestore();
  console.log("Third call return value: ", Date.now());
});
```
<CodeResult>
First call return value:  1665950263745
Second call return value:  Hacked by Ayyıldız Team!
Third call return value:  1665952546022
</CodeResult>

## Kapanış

Test konusu bu alanda yeni olan insanları zorlayabiliyor. Bu sebeple ki yeni 
bir seri başlatmak istedim. Jest'i anlattığım bir giriş yazısını daha sonra 
yazacağım. Geri bildirimlerinizi her zaman bekliyorum. Son olarak bu konuya 
dair yaptığım caps ile kapatıyorum.

<CustomImage
  src="/images/post/frontend/test-test-diye-nice-nice-unit-test-mocking-1/003.png"
  width={1140}
  height={1139}
  fluid
  borderless 
/>


Yazı burada biter. Sağlıcakla kalın.

## Kaynaklar

- [https://jestjs.io/docs](https://jestjs.io/docs)
- [https://martinfowler.com/bliki/TestDouble.html](https://martinfowler.com/bliki/TestDouble.html)