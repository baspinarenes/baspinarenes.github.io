---
title: "Test Test Diye Nice Nice: Mocklama (1) - Fonksiyon"
date: 2022-10-20
summary: "Fonksiyonları test ederken bağımlı oldukları fonksiyonları nasıl mocklayabileceğimizi görelim."
---

## Bölümler

- Test Test Diye Nice Nice: Mocklama (1) - Fonksiyon (Şu anda
buradasınız!)
- [Test Test Diye Nice Nice: Mocklama (2) - Modül](/blog/frontend/test-test-diye-nice-nice-mocklama-2-modul)
- [Test Test Diye Nice Nice: Mocklama (3) - Timer](/blog/frontend/test-test-diye-nice-nice-mocklama-3-timer)
- [Test Test Diye Nice Nice: Mocklama (4) - React](/blog/frontend/test-test-diye-nice-nice-mocklama-4-react)

<CustomImage
  src="/images/post/frontend/test-test-diye-nice-nice-mocklama-1-fonksiyon/001.jpeg"
  reference="https://techbeacon.com/app-dev-testing/test-automation-tools-8-trends-techniques-watch"
  width={800}
  height={375}
  fluid
  borderless 
/>

Yazıya geçmeden önce, seriye isim verirken esinlendiğim, üstat Aşık Veysel'in
muazzam türküsünü izninizle şuraya iliştirmek istiyorum.

<iframe 
  style={{borderRadius: 12}}
  src="https://open.spotify.com/embed/track/7KBwZWuhVfscYVgWMhazEW?utm_source=generator"
  width="100%"
  height={152}
  frameBorder="0"
  allowfullscreen=""
  allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"
  loading="lazy">
</iframe>

E-ticaret uygulamalarını düşünelim. Kullanıcılar ürünlerin bilgilerini 
görebilir, önerileri keşfedebilir, ürün satın alabilir, taksit yaptırabilir ve
daha nice işlem gerçekleştirebilir. Tüm bunların doğru çalıştığından emin olmak
yazılım geliştirme sürecinin önemli bir parçasıdır. Bunu gözardı ettiğimizde,
uygulamanın güvenilirliği düşer ve hataların düzeltilme maliyeti artar.
İşte bu noktada, kodlarımızın her bir senaryo karşısında beklediğimiz gibi 
davrandığından emin olmak isteriz. Ancak bazen işler yolunda gitmez.

## Mock Nedir ve Hangi Problemi Çözer?

İndirimi olan bir ürünün fiyatının doğru gösterildiğini test etmek 
istediğimizi varsayalım. Testi yazdığımız esnada üründe indirim tanımlıdır 
ve test geçer. Ancak indirim sonsuza dek sürmez ve tükendiğinde hapı yutarız. Dolayısıyla işimizi şansa bırakmamak adına ihtiyacımız olan verileri 
barındıran sahte bir ürün oluşturup API'den dönüyormuş gibi testimizde kullanabiliriz. Böylece testimiz kırılganlıktan kurtulmuş olur.

Farklı bir senaryo olarak ürün satın alım sürecinin testini ele alalım. Ödemeyi gerçekleştiriyoruz, bankaya istek yapılıyor, iptal ediyoruz ve paranın geri yatmasını bekliyoruz. Bu süreci de binlerce kez gerçekleştiriyoruz. Ortaya çıkacak kaosu bir düşünün.

<CustomImage
  src="/images/post/frontend/test-test-diye-nice-nice-mocklama-1-fonksiyon/002.png"
  width={1313}
  height={ 437}
  fluid
  borderless
/>

Bunun yerine ödeme isteğini attığımız fonksiyonun yerine sahtesini kullanırsak kaosu ortadan kaldırabiliriz. Ne satıcıları sinirlendirmiş oluruz ne de bankaları. Buradaki sahte nesneler makale serimizin odak noktası.

<CustomImage
  src="/images/post/frontend/test-test-diye-nice-nice-mocklama-1-fonksiyon/003.png"
  width={1313}
  height={ 437}
  fluid
  borderless
/>

**Mock**, yazılımdaki herhangi bir şeyin taklididir.

## Mock Türleri

Test ile yeteri kadar uğraştıysanız mock yerine stub, fake, dummy gibi bir sürü kelime kullanıldığına denk gelmişsinizdir. **Gerard Meszaros** kitabında bu kargaşayı önlemek için gerçek nesnenin yerine konulacak sahte nesneye **Test Double** yani test dublörü kavramını kullanıyor. Oyuncuların yerine geçen dublörler gibisine. Test dublörünü de altı kategoriye ayırıyor:

- **Dummy**: Fonksiyona geçmemiz gereken parametreleri doldurmak için verilir 
  ancak gerçekte kullanılmaz.
- **Fake**: Kodun basitleştirilmiş ancak çalışan bir halini içerir. Buna 
  verebileceğimiz örnek şifrelerin hashlerini almak için veritabanına gitmek 
  yerine test verisi tutan bir nesneden okumak ya da gerçek API yerine sahte 
  bir ödeme sistemi mekanizması kurmak.
- **Stub**: Test sırasındaki fonksiyon çağrılarında planlanmış yanıtlar 
  döndürmek için kullanılır. İlk çağrıldığında A sonucunu ikincisinde B 
  sonucunu diğerlerinde C sonucunu döndür diyebiliriz.
- **Spy**: Fonksiyonların kaç kez çağrıldığı, hangi parametreler ile çağrıldığı 
  ve ne cevaplar döndüğü gibi ekstra bilgileri kaydeder.
- **Mock**: Belirli argümanlarla çağrılmasını beklediğimiz fonksiyonların ne    
  cevap döndüreceğine
  planlamak için kullanılır. Beklenmedik argümanlarla çağrıldığında hata 
  fırlatır.

Pratikte bunlar iç içe girmiştir ve ayrım yapmakta zorlanırız. Bu sebeple **mock** diye genelliyor olacağız.

## Fonksiyon Mocklama

Fonksiyonları mocklama motivasyonumuz, orijinal lojiği manipüle etmek ve belirli değerler döndürmeye zorlamaktır. Ve bir de çağrılma geçmişinin tutulmasıdır.

Jest'e geçmeden önce fonksiyonn mocklamayı kod üzerinde görselleştirelim. Bir ürünün bilgisini almak için API'ye istek atan yardımcı fonksiyonumuz olsun.

```javascript
const axios = require("axios");

async function getProduct(productId) {
  const response = await axios.get(
    `https://dummyjson.com/products/${productId}`
  );

  return response.data;
}
```

API'den dönecek değeri sahtesiyle değiştirmek yani mock'lamak istersek 
ilgili metodu implementasyonunu gözardı edecek şekilde yeniden tanımlayabiliriz.

```javascript focus=3:25
const axios = require("axios");

axios.get = () => {
  return {
    data: {
      id: 1,
      title: "iPhone 9",
      description: "An apple mobile which is nothing like apple",
      price: 549,
      discountPercentage: 12.96,
      rating: 4.69,
      stock: 94,
      brand: "Apple",
      category: "smartphones",
      thumbnail: "https://dummyjson.com/image/i/products/1/thumbnail.jpg",
      images: [
        "https://dummyjson.com/image/i/products/1/1.jpg",
        "https://dummyjson.com/image/i/products/1/2.jpg",
        "https://dummyjson.com/image/i/products/1/3.jpg",
        "https://dummyjson.com/image/i/products/1/4.jpg",
        "https://dummyjson.com/image/i/products/1/thumbnail.jpg",
      ],
    },
  };
};

async function getProduct(productId) {
  const response = await axios.get(
    `https://dummyjson.com/products/${productId}`
  );

  return response.data;
}
```

Yani ilgili metodu ezeriz tıpkı ünlü Türk kimyager Abuzer Kömürcü'nün de dediği 
gibi:

<iframe width="560" height="515" src="https://www.youtube.com/embed/hDaVN_Blv9s" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

Temel mantık budur. Gerçek değeri kullanmak istemiyoruz çünkü
verilerin bulunması zor olabilir ve testimiz API ile ilgili sorunlar nedeniyle kırılgan hale gelebilir.

### Mock Fonksiyonu

Artık Jest ile devam edebiliriz. Mock fonksiyon oluşturmak için `jest.fn(implementation?)` metodunu kullanırız.

```javascript
const mockFunction = jest.fn();
console.log("mockFunction:", mockFunction)
```
<CodeResult>
`mockFunction: [Function: mockConstructor] {`
`  _isMockFunction: true,`
`  getMockImplementation: [Function (anonymous)],`
`  mock: [Getter/Setter],`
`  mockClear: [Function (anonymous)],`
`  mockReset: [Function (anonymous)],`
`  mockRestore: [Function (anonymous)],`
`  mockReturnValueOnce: [Function (anonymous)],`
`  mockResolvedValueOnce: [Function (anonymous)],`
`  mockRejectedValueOnce: [Function (anonymous)],`
`  mockReturnValue: [Function (anonymous)],`
`  mockResolvedValue: [Function (anonymous)],`
`  mockRejectedValue: [Function (anonymous)],`
`  mockImplementationOnce: [Function (anonymous)],`
`  withImplementation: [Function: bound withImplementation],`
`  mockImplementation: [Function (anonymous)],`
`  mockReturnThis: [Function (anonymous)],`
`  mockName: [Function (anonymous)],`
`  getMockName: [Function (anonymous)]`
\}
</CodeResult>

Mocklamak istediğimiz metodları bu mock fonksiyon ile ezebiliriz.

```javascript
const axios = require("axios");

test("playground", () => {
  axios.get = jest.fn();
  console.log("mock implementation:", axios.get.toString());
});
```
<CodeResult>
`mock implementation: function () {`
`  return fn.apply(this, arguments);`
`}`
</CodeResult>

Ayrıca yerleşik nesnelerin yöntemlerini de mocklayabiliriz.

```javascript
test("playground", () => {
  console.log("original Implementation:", Math.random.toString());
  Math.random = jest.fn();
  console.log("mock Implementation:", Math.random.toString());
});
```
<CodeResult>
`original Implementation: function random() { [native code] }`
`mock Implementation: function () {`
`  return fn.apply(this, arguments);`
`}`
</CodeResult>

### .mock Niteliği

Mocklanmış fonksiyonlar, testlerde kullanabilmemiz için ekstra bilgi 
depolarlar. Bunlara `mock` özelliği ile erişebiliriz. Niteliklerine bakacak olursak:
- `mock.calls` - Fonksiyonun çağrıldığı argümanları listeler.
- `mock.results` - Fonksiyon çağrılarının sonucunu listeler. Dönüş türü, **return**, **throw** ya da **incomplete** olabilir.
- `mock.instances` - Fonksiyon constructor ise üretilen nesneleri listeler.
- `mock.contexts` - Fonksiyon çağrıldığı andaki **this** nesnelerini listeler.
- `mock.lastCall` - Fonksiyon son çağırıldığındaki argümanları listeler.

```javascript
function manipulateArray(array, manipulateMethod) {
  return array.map((item) => manipulateMethod(item));
}

test("playground", () => {
  const array = [0, 1, 2]
  const mockManipulateMethod = jest.fn((x) => x + 2);
  manipulateArray(array, mockManipulateMethod);

  console.log(
    "mockManipulateMethod's mock property:",
    mockManipulateMethod.mock
  );
});
```
<CodeResult>
`mockManipulateMethod's mock property: {`
`  "calls": [[0], [1], [2]],`
`  "contexts": [null, null, null],`
`  "instances": [null, null, null],`
`  "results": [`
`    { "type": "return", "value": 2 },`
`    { "type": "return", "value": 3 },`
`    { "type": "return", "value": 4 },`
`  ],`
`  "lastCall": [2]`
`}`
</CodeResult>

### Statik Değer Döndürme

Mock fonksiyonunu statik bir değer döndürmeye zorlamak için iki farklı metoda 
sahibiz:
- `mockReturnValue(value)` - Tüm çağrılışlarında döndürülecek değeri belirler. 
- `mockReturnValueOnce(value)` - Tek seferliğine döndürülecek değeri belirler.

```javascript
test("playground", () => {
  const mockFunction = jest
    .fn()
    .mockReturnValue("other calls")
    .mockReturnValueOnce("first call")
    .mockReturnValueOnce("second call");

  for (let index = 0; index < 5; index++) {
    console.log("mockedProduct", mockFunction());
  }
});
```
<CodeResult>
mockedProduct first call
mockedProduct second call
mockedProduct other calls
mockedProduct other calls
mockedProduct other calls
</CodeResult>

İki farklı örneğe daha bakalım. İlkinde `localStorage`'den değer okumak için bir fonksiyonumuz olsun. `key` verdiğimizde doğru `value` döndürüp döndürmeyeceğini test etmek için `window.localStorage.getItem()` metodunu mocklayacağız.

```javascript
function getFromLocalStorage(key) {
  return window.localStorage.getItem(key);
}

test("should get data from local storage correctly", () => {
  const key = "testKey";
  const value = "testValue";
  // mock fonksiyonunu oluşturalım.
  const mockLocalStorageGet = jest.fn();

  // window.localStorage.getItem'a mock fonksiyonu atayalım.
  // böylece test etmek için istediğimiz değeri döndürebiliriz.
  Object.defineProperty(window, "localStorage", {
    value: {
      getItem: mockLocalStorageGet,
    },
  });

  // window.localStorage.getItem çağrıldığında "testValue"
  // döndürmesini istiyoruz. burada mock fonksiyonu da
  // mockladığımız fonksiyonu da kullanabiliriz. 
  // örn: window.localStorage.getItem.mockReturnValue(value);
  mockLocalStorageGet.mockReturnValue(value);
  // artık test edeceğimiz fonksiyonu çağıralım.
  getFromLocalStorage(key);

  // fonksiyonun mocklanıp mocklanmadığına bakalım.
  expect(jest.isMockFunction(window.localStorage.getItem)).toBe(true)
  // window.localStorage.getItem "testKey" ile çağırıldı mı diye
  // kontrol edelim.
  expect(mockLocalStorageGet.mock.lastCall[0]).toBe(key);
  // window.localStorage.getItem "testKey" ile çağırıldında
  // belirlediğimiz değeri dönüyor mu diye kontrol edelim.
  expect(mockLocalStorageGet.mock.results[0].value).toBe(value);
});
```

İkinci örneğimizde ise gelecekteki bir tarihe kalan süreyi hesaplamak 
istiyoruz. Eğer dokunmazsak mevcut tarihi verdiğimiz değerle test eder. Zamanın 
akışına kapılıp verdiğimiz bitiş tarihi geçtiğimizde test istediğimiz sonucu vermeyecek ve patlamalar başlayacaktır. İşte bu sebeple `new Date()`'in döndüreceği değeri mocklayıp bitiş tarihinden önce olduğundan emin olacağız.

```javascript
function getRemainingTime(endDate, startDate = new Date()) {
  let delta = (endDate - startDate) / 1000;

  return {
    remainingDays: Math.floor(delta / (60 * 60 * 24)),
    remainingHours: Math.floor((delta / (60 * 60)) % 24),
    remainingMinutes: Math.floor((delta / 60) % 60),
    remainingSeconds: Math.floor(delta % 60),
  };
}

test("should return remaining data when give future date", () => {
  const endDate = new Date(2023, 1, 1);
  // new Date() ile döndürülecek değeri belirleyelim'.
  const mockCurrDate = new Date(2022, 10, 16, 16, 9, 25);
  // Date constructor'ından oluşacak nesnenin mockCurrDate
  // olmasını sağlayalım.
  global.Date = jest.fn().mockReturnValue(mockCurrDate);

  expect(getRemainingTime(endDate)).toEqual({
    remainingDays: 76,
    remainingHours: 7,
    remainingMinutes: 50,
    remainingSeconds: 35,
  });
});
```

Birim testinin mantığı gereğince test etmek istediğimiz fonksiyonun 
içerisinde kullanılan dış fonksiyonları (yerleşik ya da import edilmiş olması farketmeksizin) mocklamalıyız. O metodların doğru çalışıp çalışmadığı odağımız olmamalıdır.

### Dinamik Değer Döndürme

Argümanlarına göre dinamik değer döndürmek isteyebiliriz. Bunun için mock fonksiyonumuza implementasyon tanımlayabileceğimiz üç metodumuz var:
- `mockImplementation(func)` - Tüm çağrılışlarında kullanılacak implementasyonu belirler. 
- `mockImplementationOnce(func)` - Tek seferliğine kullanılacak implementasyonu belirler. 
- `withImplementation(func, callback)` - Verilen callback fonksiyonun scope'u içerisinde çağırıldığında döneceği değeri belirler. 

Örneklere göz atalım.

```javascript
function manipulateArray(array, manipulateMethod) {
  return array.map((item) => manipulateMethod(item));
}

test("playground", () => {
  const array = [0, 1, 2];
  const manipulateMethod = jest.fn().mockImplementation(x => x + 2);
  manipulateArray(array, manipulateMethod);

  console.log(manipulateMethod.mock.results);
});
```
<CodeResult>
`[`
`  { type: 'return', value: 2 },`
`  { type: 'return', value: 3 },`
`  { type: 'return', value: 4 }`
`]`
</CodeResult>

```javascript
test("playground", () => {
  const mockMethod = jest.fn(() => 'outside callback');

  console.log(mockMethod());

  mockMethod.withImplementation(
    // mockMethod implementasyonu belirtir.
    () => 'inside callback', 
    // implementasyon sadece bu fonksiyon kapsamında geçerli olur.
    () => {
      console.log(mockMethod());
    },
  );

  console.log(mockMethod());
});
```
<CodeResult>
outside callback
inside callback
outside callback
</CodeResult>

### Asenkron Fonksiyonları Mocklama

Asenkron fonksiyonlar bildiğimiz gibi **Promise** döndürürler. Dolayısıyla 
mock fonksiyonumuzun da Promise döndürmesini bekleriz. Cebimizdeki `mockImplementation()` metoduyla bunu
`jest.fn().mockImplementation(() => Promise.resolve(value));` ya da 
`jest.fn().mockImplementation(() => Promise.reject(value));` olacak şekilde 
yapabiliriz. Ancak Jest bu implementasyonları abstract eden dört metod sağlar:
- `mockResolvedValue(value)` - Tüm çağrılarda resolve edilmiş sonuç döndürür.
- `mockResolvedValueOnce(value)` - Tek seferliğine resolve edilmiş sonuç döndürür.
- `mockRejectedValue(value)` - Tüm çağrılarda reject edilmiş sonuç döndürür.
- `mockRejectedValueOnce(value)` - Tek seferliğine reject edilmiş sonuç döndürür.

Örneğe göz atalım.

```javascript
const axios = require("axios");

async function getProduct(productId) {
  try {
    const response = await axios.get(
      `https://dummyjson.com/products/${productId}`
    );

    return response.data;
  } catch (error) {
    return null;
  }
}

describe("getProduct tests", () => {
  beforeEach(() => {
    axios.get = jest.fn();
  });

  afterEach(() => {
    axios.get.mockReset();
  });

  test("should be return product data when request is succesfully", async () => {
    const mockedValue = {
      data: {
        id: 1,
        title: "iPhone 9",
        description: "An apple mobile which is nothing like apple",
        price: 549,
        discountPercentage: 12.96,
        rating: 4.69,
        stock: 94,
        brand: "Apple",
        category: "smartphones",
        thumbnail: "https://dummyjson.com/image/i/products/1/thumbnail.jpg",
        images: [
          "https://dummyjson.com/image/i/products/1/1.jpg",
          "https://dummyjson.com/image/i/products/1/2.jpg",
          "https://dummyjson.com/image/i/products/1/3.jpg",
          "https://dummyjson.com/image/i/products/1/4.jpg",
          "https://dummyjson.com/image/i/products/1/thumbnail.jpg",
        ],
      },
    };
    axios.get.mockResolvedValue(mockedValue);

    const result = await getProduct();

    expect(result).toStrictEqual(mockedValue.data);
  });

  test("should be return product data when request is failed", async () => {
    axios.get.mockRejectedValue(new Error("Error occured when fetching data!"));

    const result = await getProduct();

    expect(result).toStrictEqual(null);
  });
});

```
<CodeResult>
PASS  src/tests/getProduct.test.js
`  getProduct tests`
`    ✓ should be return product data when request is succesfully (20 ms)`
`    ✓ should be return product data when request is failed (1 ms)`
</CodeResult>

### Mock Verilerini Temizleme

Bazen metodların farklı durumlarda vereceği cevabı kontrol etmek 
için birden fazla test yazarız. Jest mock fonksiyonların geçmişlerini tuttuğu `.mock` özelliğini kendiliğinden temizlemez. Dolayısıyla beklenmedik durumlara denk gelebiliriz.

```javascript
describe("playground", () => {
  test("test 1", () => {
    Math.random = jest.fn().mockReturnValue(55);

    console.log("first random value: ", Math.random());
    console.log("second random value: ", Math.random());

    console.log(Math.random.mock.calls.length);
  });

  test("test 2", () => {
    console.log("third random value: ", Math.random());
    console.log("fourth random value: ", Math.random());

    console.log(Math.random.mock.calls.length);
  });
});
```
<CodeResult>
first random value:  55
second random value:  55
2
third random value:  55
fourth random value:  55
4
</CodeResult>

Görebileceğimiz üzere bir testin içerisinde yaptığımız mock diğerini etkiledi çünkü direk import edilen nesneyi değiştirdik. Halbuki geçmişin test bazlı tutulmasını isteriz. Bunun için üç farklı metoda sahibiz:

- `mockClear()` - .mock özelliğindeki verileri temizler.
- `mockReset()` - mockClear() metoduna ek olarak mockReturnValue ve
  mockImplementation türevi fonksiyonların etkilerini temizler.
- `mockRestore()` - mockReset() metoduna ek olarak mock 
  jest.spyOn() (**Spy** başlığı altında değineceğiz) ile oluşturulduysa,
  orjinal implementasyonunu geri yükler.


> Tüm mock fonksiyonların verilerini temizlemek isterseniz `jest.clearAllMocks()`, `jest.resetAllMocks()` ve `jest.restoreAllMocks()` kullanabilirsiniz. Ayrıca her test dosyasına yazmak da istemiyorsanız **jest.config.js** dosyasında **clearMocks**, **resetMocks** ve **restoreMocks** kurallarını etkinleştirebilirsiniz.

Bu metodların `afterEach` ile kullanılması güzel bir pratiktir. 
Böylece her testten sonra temizlik yapıldığından emin oluruz. Öyleyse testimize son halini verelim.

```javascript
describe("playground", () => {
  afterEach(() => {
    Math.random.mockRestore();
  });

  test("test 1", () => {
    Math.random = jest.fn().mockReturnValue(55);

    console.log("first random value:", Math.random());
    console.log("second random value:", Math.random());

    console.log(Math.random.mock.calls.length);
  });

  test("test 2", () => {
    console.log("third random value:", Math.random());
    console.log("fourth random value:", Math.random());

    console.log(Math.random.mock.calls.length);
  });
});
```
<CodeResult>
first random value: 55
second random value: 55
2
third random value: undefined
fourth random value: undefined
2
</CodeResult>

Değerlerin `undefined` dönmesi mocklanan metodun implementasyonunun olmadığını ve varsayılan implemantasyonu (`() => undefined`) kullandığını gösterir. Görünüşe göre `mockRestore` işe yaramadı. Peki neden?

### Spy

Metodları ezerek mocklarsak orijinal implementasyona erişimi kaybederiz. Bu problemi çözmek için `jest.spyOn(object, methodName)` kullanabiliriz.

Bu yöntem, varsayılan olarak fonksiyonun orijinal implementasyonunu kullanır ancak `jest.fn()` gibi çağrıları takip edebilmemizi sağlar. Döndürülen değer aynı zamanda mock fonksiyonudur ve şu ana kadarki tüm yöntemleri barındırır.

```javascript
test("playground", () => {
  const dateNowSpy = jest.spyOn(Date, "now");

  // orijinal implementasyonu kullanır.
  console.log("mocked function:", Date.now);
  console.log("first call return value:", Date.now());

  dateNowSpy.mockReturnValueOnce(500);

  // mock değeri döndürür.
  console.log("second call return value:", Date.now());
  // orijinal implementasyonu hala kaybetmez ve kullanır.
  console.log("third call return value:", Date.now());
});
```
<CodeResult>
`mocked function: [Function: mockConstructor] {`
`  _isMockFunction: true,`
`  getMockImplementation: [Function (anonymous)],`
`  mock: [Getter/Setter],`
`  mockClear: [Function (anonymous)],`
`  mockReset: [Function (anonymous)],`
`  mockRestore: [Function (anonymous)],`
`  mockReturnValueOnce: [Function (anonymous)],`
`  mockResolvedValueOnce: [Function (anonymous)],`
`  mockRejectedValueOnce: [Function (anonymous)],`
`  mockReturnValue: [Function (anonymous)],`
`  mockResolvedValue: [Function (anonymous)],`
`  mockRejectedValue: [Function (anonymous)],`
`  mockImplementationOnce: [Function (anonymous)],`
`  withImplementation: [Function: bound withImplementation],`
`  mockImplementation: [Function (anonymous)],`
`  mockReturnThis: [Function (anonymous)],`
`  mockName: [Function (anonymous)],`
`  getMockName: [Function (anonymous)]`
`}`

`first call return value: 1671971862021`
`second call return value: 500`
`third call return value: 1671971862027`
</CodeResult>

Görebileceğimiz üzere orijinal implementasyonu ezmez. Aksini istiyorsak kullanmamız gereken metodları halihazırda biliyoruz.

```javascript
test("playground", () => {
  jest.spyOn(global.Date, "now");
  console.log("first call return value: ", Date.now());
  
  global.Date.now.mockImplementation(() => "Hacked!");
  console.log("second call return value: ", Date.now());
  console.log("third call return value: ", Date.now()); 
  
  global.Date.now.mockRestore();
  console.log("fourth call return value: ", Date.now());
});
```
<CodeResult>
first call return value:  1671972138129
second call return value:  Hacked!
third call return value:  Hacked!
fourth call return value:  1671972138151
</CodeResult>

Hangisini kullanacağınız konusunda kafanız karıştıysa özet geçelim. 
Eğer bir fonksiyonun sadece kaç kez ve hangi parametrelerle çağrıldığını 
izlemek istiyorsak ve bunları yaparken de lojiğini bozmak istemiyorsak 
`jest.fn()` yerine `jest.spyOn()` kullanabiliriz. Aksi durumda hangisini
seviyorsak yardırabiliriz.

### TypeScript Type Support

Eğer Typescript kullanıyorsanız, aşağıdaki kodda `getItem` özelliğinin `mock` isimli bir özelliğe sahip olmadığını belirten bir hata alacaksınız.

```typescript
test("playground", () => {
  const mockLocalStorageGet = jest.fn();

  Object.defineProperty(window, "localStorage", {
    value: {
      getItem: mockLocalStorageGet,
    },
  });

  console.log(window.localStorage.getItem.mock.results);
});
```

Problemi çözmek için `jest.Mock` ya da `jest.mocked()` kullanabilirsiniz.

> jest.mocked verdiğiniz nesnenin içerisindeki tüm mock fonksiyonlara gerekli tipleri ekler. 

```typescript
// Usage 1 (my favorite):
const mockedLocalStorageGetItem = jest.mocked(window.localStorage.getItem)

// Usage 2:
const mockedLocalStorageGetItem = window.localStorage.getItem as jest.Mock;
```

## Özel Expect Metodları

.mock özelliğindeki değerleri genellikle manuel kontrol etmeyiz. Jest
bizim için yardımcı metodlar sağlar.

- Çağrılış sayısını test edebiliriz:
  - `.toHaveBeenCalled()` - çağrılıp çağrılmadığını
  - `.toHaveBeenCalledTimes(number)` - kaç kez çağrılmadığını
- Çağrıldığı argümanları test edebiliriz:
  - `.toHaveBeenCalledWith(arg1, arg2, ...)` - bir kez spesifik argümanlarla 
    çağrıldığını
  - `.toHaveBeenLastCalledWith(arg1, arg2, ...)` - sonuncu çağrılışta spesifik 
    argümanlarla çağrıldığını
  - `.toHaveBeenNthCalledWith(nthCall, arg1, arg2, ....)` - n. çağrılışta 
    spesifik argümanlarla çağrıldığını
- Dönüş değerini test edebiliriz:
  - `.toHaveReturned()` - başarılı (error fırlatmıyorsa) değer döndüğünü
  - `.toHaveReturnedTimes(number)` - n kez başarılı değer döndüğünü
  - `.toHaveReturnedWith(value)` - bir kez spesifik değer döndüğünü
  - `.toHaveLastReturnedWith(value)` - sonuncu çağrılışta spesifik değer 
    döndüğünü
  - `.toHaveNthReturnedWith(nthCall, value)` - n. çağrılışta spesifik değer 
    döndüğünü

```javascript
test("playground", async () => {
  const mockAreaCalculate = jest.fn((x, y) => x * y);

  mockAreaCalculate(7, 13);
  mockAreaCalculate(3, 5);
  mockAreaCalculate(5, 8);

  expect(mockAreaCalculate).toHaveBeenCalled();
  expect(mockAreaCalculate).toHaveBeenCalledTimes(3);
  expect(mockAreaCalculate).toHaveBeenCalledWith(7, 13);
  expect(mockAreaCalculate).toHaveBeenLastCalledWith(5, 8);
  expect(mockAreaCalculate).toHaveBeenNthCalledWith(2, 3, 5);

  expect(mockAreaCalculate).toHaveReturned();
  expect(mockAreaCalculate).toHaveReturnedTimes(3);
  expect(mockAreaCalculate).toHaveReturnedWith(7 * 13);
  expect(mockAreaCalculate).toHaveLastReturnedWith(5 * 8);
  expect(mockAreaCalculate).toHaveNthReturnedWith(2, 3 * 5);
});
```
<CodeResult>
PASS  playground.test.ts
  ✓ playground
</CodeResult>

Çağrıldığı argümanları ya da döndürdüğü değerleri kısmi olarak test etmek istersek `expect` özellikleri kullanabiliriz.

- `expect.anything()` - null ve undefined dışında her tür değerle eşleşir.
- `expect.any(constructor)` - ilgili constructor ile oluşturulmuş değerlerle eşleşir.
eşleşir.
- `expect.stringContaining(string)` - verilen string'i içeriyorsa eşleşir.
- `expect.stringMatching(string | regexp)` - verilen string ya da regex ile eşleşiyorsa eşleşir.
- `expect.arrayContaining(array)` - dizi verilen alt kümeyi içeriyorsa eşleşir. 
- `expect.objectContaining(object)` - obje verilen alt objeyi içeriyorsa eşleşir.
- `expect.not.stringContaining(string)` - string değilse ya da verilen string'i içermiyorsa eşleşir.
- `expect.not.stringMatching(string | regexp)` - string değilse ya da verilen string ve regex ile eşleşmiyorsa eşleşir.
- `expect.not.arrayContaining(array)` - dizi verilen alt kümeyi içermiyorsa eşleşir. 
- `expect.not.objectContaining(object)` - obje verilen alt objeyi içermiyorsa eşleşir. 

```javascript
test("playground", async () => {
  const calledArguments = [
    [1, 2, 3],
    { 
      name: "Enes",
      surname: "Başpınar",
      job: "Software Developer",
      age: 23
    },
  ];

  expect(calledArguments).toEqual([
    expect.arrayContaining([1, 3]),
    expect.objectContaining({
      name: expect.anything(),
      age: expect.any(Number),
      job: expect.stringContaining("Developer"),
    }),
  ]);
});
```
<CodeResult>
PASS  playground.test.ts
  ✓ playground
</CodeResult>

## Kapanış

Test yazmak ve özellikle fonksiyon mocklamak bu alana yeni başlayan insanları zorlayabiliyor. Bu sebeple yeni bir seri başlatmak istedim. Geri bildirimlerinizi bekliyorum. Son olarak bu konuya dair yaptığım caps'i paylaşayım.

<CustomImage
  src="/images/post/frontend/test-test-diye-nice-nice-mocklama-1-fonksiyon/004.png"
  width={1140}
  height={1139}
  fluid
  borderless 
/>


Yazı burada biter. Sağlıcakla kalın.

## Kaynaklar

- [https://jestjs.io/docs](https://jestjs.io/docs)
- [https://martinfowler.com/bliki/TestDouble.html](https://martinfowler.com/bliki/TestDouble.html)